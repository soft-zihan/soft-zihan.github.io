# 浏览器和网络

## 浏览器

### 浏览器概述

浏览器是一个多进程的架构，我们关心的是渲染进程( **核心进程** )。

**为何使用多进程架构?**

由于多个线程共享着相同的地址空间和资源,所以会存在线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。

 **单进程浏览器** ：

1、不稳定。单进程中的插件、渲染线程崩溃导致整个浏览器崩溃。

2、不流畅。脚本（死循环）或插件会使浏览器卡顿。

3、不安全。插件和脚本可以获取到操作系统任意资源。

 **多进程浏览器** ：

1、解决不稳定。进程相互隔离，一个页面或者插件崩溃时，影响仅仅时当前插件或者页面，不会影响到其他页面。

2、解决不流畅。脚本阻塞当前页面渲染进程，不会影响到其他页面。

3、解决不安全。采用多进程架构使用沙箱。沙箱看成是操作系统给进程上来一把锁，沙箱的程序可以运行，但不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据。

> 将渲染进程和OS隔离的这道墙就是安全沙箱。 作用：利用OS提供的安全技术，让渲染进程在执行过程中无法访问或修改OS中的数据，在渲染进程需要访问系统资源的时候，需通过浏览器内核实现，将访问结果通过IPC转发给渲染进程。 最小的保护单位是进程。单进程浏览器需要频繁访问或修改OS的数据，所以单进程浏览器无法被安全沙箱保护。

**主要进程**

浏览器是多进程的. 主要分为：

**浏览器主进程**

只有一个，控制页面的创建、销毁、网络资源管理、下载等, 同时提供存储等功能 。

**第三方插件进程**

每一种类型的插件对应一个进程，仅当使用该插件时才创建。 主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响.

**GPU进程**

最多一个，用于3D绘制等,从浏览器进程中独立出来的。

**浏览器渲染进程(浏览器内核)**

**每个Tab页对应一个进程，互不影响 , 核心任务是将HTML、CSS 和 JavaScript转换为可以与用户交互的网页。** 出于安全考虑，渲染进程都是运行在沙箱模式下。

**网络进程**

从浏览器进程中独立出来的, 主要负责页面的网络资源加载。

**GUI 线程**

负责渲染页面，解析 html、css；构建 DOM 树和渲染树；当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的,也就是说被”冻结”了.

**js 引擎线程**

负责解析和执行 js 程序，我们经常听到的 chrome 的 v8 引擎就是跑在 js 引擎线程上的，其实语言没有单线程多线程之说，因为解释这个语言的是 的线程是单线程；js 引擎线程与 gui 线程互斥，当浏览器执行 javaScript 程序的时候，GUI 渲染线层会保存在一个队列当中；直到 js 程序执行完成，才会接着执行；如果 js 的执行时间过长，会影响页面的渲染不连贯，所有我们要尽量控制 js 的大小。

JS引擎线程和GUI渲染线程互斥！

**定时触发线程**

浏览器定时计数器并不是由JS引擎计数的, 因为JS引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。

为什么 setTimeout 不阻塞后面程序的运行，因为 setTimeout 不是由 js 引擎线程完成的，是由定时器触发线程完成的，所以它们可以同时进行，那么定时器触发线程在这定时任务完成之后会通知事件触发线程往任务队列里添加事件。

**事件触发线程**

当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。

**异步 HTTP 请求线程**

在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。

**异步场景**

1. 定时器
2. 网络请求
3. 事件绑定
4. ES6 Promise

**定时器**

执行调用栈的代码，栈中为空时去检查任务队列，这是一个循环检查的过程，等到事件触发线程往任务队列中添加了定时器事件，这时再去检查已经有了定时器的异步任务，取出放进执行栈执行。

**带来问题**

定时任务可能不会按时执行。

**应用场景**

1. 防抖节流
2. 倒计时
3. 动画(丢帧问题)

**内核**

浏览器内核是通过取得页面内容、整理信息、计算和组合最终输出可视化图像结果（渲染引擎）

每一个tab页面可以看作是浏览器内核进程， **浏览器内核是多线程的** 。

**常见浏览器内核**

Trident内核：IE，360，搜狗等浏览器

Gecko内核：Netscape6及以上版本，Firefox

Blink内核：Opera7及以上

Webkit内核：Safari，Chrome

**检测版本**

1. 检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent的值为 Mozilla来躲过服务器的检测。
2. 功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。

### 浏览器：事件循环

**1. Event Loop**

> Js引擎在执行代码时候会产生执行栈，当调用异步 API，例如 setTimeout，setInterval，Promise 等回调触发时，就会进入异步任务队列，当同步代码执行完成后，就会去异步队列取出回调函数并执行，这样就形成了一个事件循环。在 Javascript 中有两种任务类型，分别是 宏任务 和 微任务 。

事件循环唯一任务：将队列和调用堆栈连接起来。

事件队列是一个存储执行任务的队列。

执行栈类似于函数调用栈的运行容器，当其为空时，JS检查事件队列，将第一个任务压入栈中执行。若调用栈和微任务队列为空，事件循环检查宏任务队列是否还有任务，从中弹出进入调用栈执行完再弹出。

* setTimeout的时间不是指马上执行，而是最快可以多久后执行，因为它会等待调用 栈为空时执行。
* 浏览器的渲染必须要调用栈为空时才会执行，正常的 forEach 会阻塞渲染。
* 在一个回调出栈，另一个回调进栈的间隙(此时栈空)，渲染得以顺利进行。

**单线程JS实现异步**

浏览器的内核多线程实现。

**script是宏任务**

若存在两个script代码块，首先执行第一个 script 中的同步代码，若这个过程中创建了微任务并进入了微任务队列，第一个 script 同步代码执行完之后，首先清空微任务队列，再去开启第二个 script 的执行。

**js单线程问题**

所有任务都在一个线程上完成，一旦遇到大量任务或遇到一个耗时的任务，网页就可能出现卡死，也无法响应用户的行为。

setTimeout如果在主线程上运行就会阻塞其他活动。

所以，需要做的就是，离开这个线程，同时运行这个任务。

JavaScript的单线程，与它的用途有关。

作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。

比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

**Event Loop **

是一个程序结构，用户等待和发送信息的事件。

简单说就是在程序中设置 2 个线程，一个负责程序本身的运行，称为“主线程”；另一个负责主线程和其他进程（主要是各种 I/O 操作）的通信 被称为“Event Loop 线程”（也可以翻译为消息线层）

js 就是采用了这种机制，来解决单线程带来的问题。

**浏览器的 Event Loop**

microtask在事件循环的macrotask执行完之后执行。

**macro（宏任务）有多个，微任务（micro）队列只有一个。**

先执行宏任务，再执行微任务，执行宏任务的过程中遇到微任务，依次加入微任务队列。

**异步实现**

1. 宏观：浏览器多线程（从宏观来看是多线程实现了异步）
2. 微观：Event Loop，事件循环（Event Loop 翻译是事件循环，是实现异步的一种机制）

**常见的macrotask有：(一般由浏览器发起)**DOM渲染后触发

1. script整体代码
2. setImmediate：node 的方法
3. setTimeout 和 setInterval
4. requestAnimationFrame
5. I/O
6. UI rendering

 **常见的microtask有：** (一般由JS自身创建)DOM渲染前触发

1. process.nextTick (Node环境中)
2. Promise callback(例如 promise.then)
3. Object.observe (基本上已经废弃)
4. MutationObserver

**运行过程**

线程都有自己的运行数据存储空间，堆的空间比较大，所以存储一些对象；

栈的空间比较小，所以存储一些基础数据类型、对象的引用，函数的调用；

函数调用就入栈，执行完函数体的代码自动从栈中弹出——调用栈。

当栈中的函数出栈时，栈为空的话，我们会调用一些异步函数，这个异步函数会找它们的异步处理模块，异步处理模块包括定时器、promise、Ajax等，异步处理模块会找它们各自对应的线程，线程向任务队列中添加事件，再从任务队列中取出事件，去执行对应的回调。

3个注意点：

1. 整个script代码块属于宏任务
2. 当宏任务执行完，会去执行所有微任务
3. 微任务执行完再去执行下一个宏任务，等调用栈为空时执行一个微任务；调用栈不为空时，任务队列的微任务一直等待；微任务执行完又去取任务队列的宏任务**，依次执行宏任务，执行宏任务时检查当前是否存在微任务，若有微任务就去 执行完所有微任务，然后 再去执行后续的宏任务 。**

**注意点：**

1. 一个 Event Loop 有一个或多个 task queue（任务队列）
2. 每个 Event Loop 有一个 microtask queue（微任务队列）
3. requestAnimationFrame 不在任务队列也不在为任务队列，**在渲染阶段执行**
4. 任务需要多次事件循环才能执行完，**微任务是一次性执行完**
5. 主程序和 setTimeout 都是宏任务，一个 promise 是微任务，第一个宏任务（主程序）执行完，执行全部的微任务（一个 promise），再执行下一个宏任务（setTimeout）

记住一点，要把本次宏任务下所产生的微任务全部执行完才会执行下一个宏任务，记住是产生的，没有产生的不会执行！

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code class="language-javascript hljs" node="[object Object]" data-highlighted="yes">//async函数是对一些异步操作的处理方式，一旦调用会立即执行，其中可包含微任务和宏任务
// await语句后面的代码回放进微任务队列执行
async function async1() {

    console.log('async1 start')

    //await是等待，需要把第一轮微任务执行完，再执行下面的内容

    //await后面的内容执行完，又执行宏任务

    await async2()

    console.log('async1 end')
}

async function async2() {

    return Promise.resolve().then(_ => {

        console.log('async2 promise')
    })
}

console.log('start')

setTimeout(function () {

    console.log('setTimeout')
}, 0)

async1()

new Promise(function (resolve) {

    console.log('promise1')

    resolve()

}).then(function () {

    console.log('promise2')
})

//start

//async1 start

//promise1

//async2 promise

//promise2

//async1 end

//setTimeout
</code></div></pre>

**所谓一轮事件循环就是第一轮宏任务和微任务结束。**当微任务队列清空后,一个事件循环结束。

所以正确的一次 Event loop 顺序是：

1. 执行同步代码，这属于宏任务
2. 执行栈为空，查询是否有微任务需要执行
3. 执行所有微任务
4. 必要的话渲染 UI
5. 然后开始下一轮 Event loop，执行宏任务中的异步代码

通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。

**2. Node事件循环**

microtask 在事件循环的各个阶段之间执行（一个阶段执行完毕，就会去执行microtask队列任务）。和浏览器不同，浏览器时每次取一个宏任务执行,执行完后就跑去检查微任务队列.

 **但nodejs是来都来了,一次全部执行完该阶段的任务好了** ,那么process.nextTic和微任务啥时候执行?**process.nextTick会优先于微任务.**

**事件循环顺序**

![](https://notes.kamacoder.com/pics/_%E5%89%8D%E7%AB%AF_%E6%B5%8F%E8%A7%88%E5%99%A801_%E8%BE%B0%E4%B9%9D%E4%B9%9D.png)

执行的几个阶段

1. **timers 阶段：执行 timers 的回调，也是执行 setTimeout 和 setInterval 的回调**
2. pending IO callbacks：系统操作的回调，如定时器和setImmediate回调。
3. idle，prepare：内部使用
4. **poll：等待新的 I/O 事件进来,其他所有宏任务都属于poll阶段** ，此阶段，系统会做两件事：
5. 执行到点的定时器
6. 执行 poll 队列中的事件
7. 且当 poll 中没有定时器的情况下，会发生以下两件事

* 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制
* 如果 poll 队列为空，会有两件事发生
  * 如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate
  * 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调

6. 如果有别的定时器需要被执行，会回到 timer 阶段执行回调。
7. **check：执行 setImmediate 回调**
8. close callbacks：内部使用

**只需关注 1、4、5 阶段**

每个阶段都有一个 callbacks 的先进先出的队列需要执行，当 event loop 运行到一个指定阶段时，该阶段的 fifo 队列将会被执行，当队列 callback 执行完或者执行的 callbacks 数量超过该阶段的上限时，event loop 会转入下一个阶段。

**setTimeout 和 setImmediate**

二者非常相似，区别主要在于调用时机不同。

* setImmediate 设计在 poll 阶段完成时执行，即 check 阶段；
* setTimeout 设计在 poll 阶段为空闲时，且设定时间到达后执行，但它在 timer 阶段执行

**区别**

* node采用js v8作为解释器，v8解析完代码之后去调用node相关api
* Timer: setTimout
* IO: 进行一些IO事件
* Idle,prepare
* poll: 先看poll队列有没有事件，没有，查看是否有setImmediate的cb或者到期的timer，如果有，就放到timer queue中；如果这两个都空，就会等一个IO事件返回
* check：poll空闲的时候，进入这个阶段setImmediate
* Close callbacks：socket.destory()当socket连接在这个阶段关闭，close回调在这个阶段执行
* 因为在I/O事件的回调中，setImmediate方法的回调永远在timer的回调前执行。
* nextTick在一个阶段执行完成之后优先执行

### 浏览器内核

**一、 浏览器的组成**

`浏览器的组成，主要分为两部分 外壳+内核`。

外壳指菜单、工具栏等，主要是为用户界面操作、参数设置等提供的。它调用内核来实现各种功能。

内核是浏览器的核心，内核是基于标记语言显示内容的程序或模块。（我们可以写插件的，就是能对外壳进行定义，以及调用一些内核API，感觉挺好玩的，还没试过~~~）

**二、浏览器作用**

向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI指定，浏览器根据HTML规范进行解释。

**三、浏览器内核**

 **浏览器的核心部分是“渲染引擎”也会简称“浏览器内核，负责解释页面语法（HTML、CSS 解析、页面布局）和渲染（显示）页面** 。但是现在一般我们提到的大部分“浏览器内核”都包含了 JavaScript 引擎，用来处理一些动作，动态效果，所以我们可以一般认为浏览器内核包含渲染引擎和JavaScript引擎。因为浏览器的引擎不同，对我们的网页语法的解析就会产生一些不同。所以我们写CSS的时候，一般会对全局进行一些初始化，以及我们需要对页面做兼容性处理。

**四、浏览器使用的内核分类**

* **Trident 内核** ：IE、MaxThon、TT、The World、360、搜狗浏览器等（当年的大哥了，没落后，IE都被淘汰了，不过国内一些老的机构的页面还是基于IE的，比如教师资格考试就要在IE上报名）
* **Gecko 内核** ：Netscape6 及以上、FF、MozillaSuite/SeaMonkey 等（什么鬼东西，要不是搜了，都没听过）
* **Presto 内核** ：Opera7 及以上
* **Webkit 内核** ：Safari、Chrome 等

### 浏览器同源策略

一个域下的JS脚本在未经允许的情况下，不能访问另一个域的内容，同源指的是 协议 域名 和 端口均相等的情况，为同一个域。

> **跨域**

**由于同源策略的限制，请求发送到后端，后端返回数据时被浏览器的跨域报错拦截。**

问：跨域的请求在服务端会不会真正执行?

服务端就算是想拦截，也没法判断请求是否跨域，HTTP Reqeust 的所有 Header 都是可以被篡改的，它用什么去判断请求是否跨域呢？很明显服务端心有余而力不足啊！

请求一定是先发出去，在返回来的时候被浏览器拦截了，如果请求是有返回值的，会被浏览器隐藏掉。

 **options** :预检请求有一个很重要的作用就是 询问 服务端是不是允许这次请求，如果当前请求是个跨域的请求，你可以理解为：询问 服务端是不是允许请求在当前域下跨域发送。

当然，它还有其他的作用，比如 询问 服务端支持哪些 HTTP 方法。

预检请求虽然不会真正在服务端执行逻辑，但也是一个请求啊，考虑到服务端的开销，不是所有请求都会发送预检的。

**一旦浏览器把请求判定为 简单请求，浏览器就不会发送预检了。**

所以，如果你发送的是一个简单请求，这个请求不管是不是会受到跨域的限制，只要发出去了，一定会在服务端被执行，浏览器只是隐藏了返回值而已。

对于前端开发而言，大部分的跨域问题，都是通过代理解决的。

代理使用的场景是：生产环境不发生跨域，但开发环境发生跨域。所以，只需要在开发环境使用代理解决跨域即可——开发代理。

> **解决跨域**

**JSONP**

前后端配合。只支持GET方法且不安全。利用src发送请求，传递一个回调。

不受跨域问题限制：script，link，img，href，src，因为这些操作都不会通过响应结果进行可能出现安全问题的操作。

通过

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code class="language-javascript hljs" node="[object Object]" data-highlighted="yes">//去创建一个script标签
var script = document.createElement("script");

//script的src属性设置接口地址 并带一个callback回调函数名称
script.src = "http://127.0.0.1:8888/index.php?callback=jsonpCallback";

//插入到页面
document.head.appendChild(script);

//通过定义函数名去接收后台返回数据
function jsonpCallback(data) {

    //注意 jsonp返回的数据是json对象可以直接使用

    //ajax 取得数据是json字符串需要转换成json对象才可以使用。
}
</code></div></pre>

**postMessage**

(传输数据)

这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

**CORS**

**跨域资源共享 Cross Origin Resourse-Sharing**

**一般后端开启。**是基于HTTP1.1的一种跨域解决方案。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示 **哪些域名可以访问资源** ，如果设置通配符则表示所有网站都可以访问资源。

一个请求可以附带很多信息，会对服务器造成不同程度的影响，又得请求只是获取一些新闻，有的请求会改动服务器的数据。

针对不同的请求，CORS规定了3种不同的交互模式

* 简单请求
* 需要预检的请求
* 附带身份凭证的请求

**简单请求**

当请求**同时满足**以下条件时，浏览器会认为它是一个简单请求：

**1.请求方法属于下面的一种：**

* get
* post
* head

**2.请求头仅包含安全的字段，常见的安全字段如下：**

* Accept
* Accept-Language
* Content-Language
* Content-Type
* DPR
* Downlink
* Save-Data
* Viewport-Width
* Width

**3.请求头如果包含Content-Type，仅限下面的值之一：**

* text/plain
* multipart/form-data
* application/x-www-form-urlencoded

4.请求中的任意 XMLHttpRequest 对象均没有注册任何事件监听器；XMLHttpRequest 对象可以使用 XMLHttpRequest.upload 属性访问。

5.请求中没有使用 ReadableStream 对象。

如果以上条件同时满足，浏览器判定为简单请求。

当浏览器判定某个**ajax 跨域请求**是**简单请求**时，会发生以下的事情

**1. 请求头中会自动添加Origin字段**

比如，在页面[http://my.com/index.html中有以下代码造成了跨域](http://my.com/index.html%E4%B8%AD%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E9%80%A0%E6%88%90%E4%BA%86%E8%B7%A8%E5%9F%9F)

// 简单请求

fetch('[http://crossdomain.com/api/news](http://crossdomain.com/api/news)');

请求发出后，请求头会是下面的格式：

GET /api/news/ HTTP/1.1

Host: crossdomain.com

Connection: keep-alive

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code class="language-javascript hljs" node="[object Object]" data-highlighted="yes">Referer: http://my.com/index.html

Origin: http://my.com
</code></div></pre>

最后一行，Origin字段会告诉服务器，是哪个源地址在跨域请求

**2. 服务器响应头中应包含Access-Control-Allow-Origin**

当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加Access-Control-Allow-Origin字段

该字段的值可以是：

* *：表示我很开放，什么人我都允许访问
* 具体的源：比如[http://my.com，表示我就允许你访问](http://my.xn--com,-yo6fo3h8t1a0xkuy4cjz5awvhpc769o/)

> 实际上，这两个值对于客户端[http://my.com而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许](http://my.xn--com,,,-en7ipda26bm9ckxad1tbab31fmb162bltiesm2ncw87bj4ci1o3nlf5p8qag48fwxfe4ju96cnz8e61els9b0xnrl1dvjkmoqka1405c/)
>
> 当然，服务器也可以维护一个可被允许的源列表，如果请求的Origin命中该列表，才响应*或具体的源
>
> **为了避免后续的麻烦，强烈推荐响应具体的源**

假设服务器做出了以下的响应：

HTTP/1.1 200 OK

Date: Tue, 21 Apr 2020 08:03:35 GMT

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code class="language-javascript hljs" node="[object Object]" data-highlighted="yes">Access-Control-Allow-Origin: http://my.com
</code></div></pre>

消息体中的数据

当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给 js，以完成后续的操作

**需要预检请求**

但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：

1. **浏览器发送预检请求，询问服务器是否允许**
2. **服务器允许**
3. **浏览器发送真实请求**
4. **服务器完成真实的响应**

比如，在页面[http://my.com/index.html中有以下代码造成了跨域](http://my.com/index.html%E4%B8%AD%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E9%80%A0%E6%88%90%E4%BA%86%E8%B7%A8%E5%9F%9F)

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code class="language-javascript hljs" node="[object Object]" data-highlighted="yes">// 需要预检的请求
fetch('http://crossdomain.com/api/user', {

    method: 'POST', // post 请求

    headers: {

        // 设置请求头
        a: 1,

        b: 2,

        'content-type': 'application/json',
    },

    body: JSON.stringify({
        name: '袁小进',
        age: 18
    }), // 设置请求体
});
</code></div></pre>

浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互

**1.浏览器发送预检请求，询问服务器是否允许**

OPTIONS /api/user HTTP/1.1

Host: crossdomain.com

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code class="language-javascript hljs" node="[object Object]" data-highlighted="yes">Origin: http://my.com

Access-Control-Request-Method: POST

Access-Control-Request-Headers: a, b, content-type
</code></div></pre>

可以看出，这并非我们想要发出的真实请求，请求中不包含我们的请求头，也没有消息体。

这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。

预检请求 **没有请求体** ，它包含了后续真实请求要做的事情

预检请求有以下特征：

* 请求方法为OPTIONS
* 没有请求体
* 请求头中包含
  * Origin：请求的源，和简单请求的含义一致
  * Access-Control-Request-Method：后续的真实请求将使用的请求方法
  * Access-Control-Request-Headers：后续的真实请求会改动的请求头

**2.服务器允许**

服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式

HTTP/1.1 200 OK

Date: Tue, 21 Apr 2020 08:03:35 GMT

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code class="language-javascript hljs" node="[object Object]" data-highlighted="yes">Access-Control-Allow-Origin: http://my.com

Access-Control-Allow-Methods: POST

Access-Control-Allow-Headers: a, b, content-type

Access-Control-Max-Age: 86400
</code></div></pre>

对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：

* Access-Control-Allow-Origin：和简单请求一样，表示允许的源
* Access-Control-Allow-Methods：表示允许的后续真实的请求方法
* Access-Control-Allow-Headers：表示允许改动的请求头
* Access-Control-Max-Age：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了

**3. 浏览器发送真实请求**

预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据

POST /api/user HTTP/1.1

Host: crossdomain.com

Connection: keep-alive

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code class="language-javascript hljs" node="[object Object]" data-highlighted="yes">Referer: http://my.com/index.html

Origin: http://my.com

{"name": "xiaoming", "age": 18 }
</code></div></pre>

**4.服务器响应真实请求**

HTTP/1.1 200 OK

Date: Tue, 21 Apr 2020 08:03:35 GMT

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code class="language-javascript hljs" node="[object Object]" data-highlighted="yes">Access-Control-Allow-Origin: http://my.com
</code></div></pre>

添加用户成功

可以看出，当完成预检之后，后续的处理与简单请求相同

**附带身份凭证请求**

默认情况下，ajax 的跨域请求并不会附带 cookie，这样一来，某些需要权限的操作就无法进行

不过可以通过简单的配置就可以实现附带 cookie

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code class="language-javascript hljs" node="[object Object]" data-highlighted="yes">// xhr
var xhr = new XMLHttpRequest();

xhr.withCredentials = true;

// fetch api
fetch(url, {
	credentials: 'include',
});
</code></div></pre>

当一个请求需要附带 cookie 时，无论它是简单请求，还是预检请求，都会在请求头中添加cookie字段

而服务器响应时，需要明确告知客户端：服务器允许这样的凭据

告知的方式也非常的简单，只需要在响应头中添加：Access-Control-Allow-Credentials: true即可

对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。

另外要特别注意的是： **对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为** *。这就是不推荐使用*的原因

> **额外补充**

在跨域访问时，JS 只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。

Access-Control-Expose-Headers头让服务器把允许浏览器访问的头放入白名单，例如：

Access-Control-Expose-Headers: authorization, a, b

这样 JS 就能够访问指定的响应头了。

**代理**

适用场景：生产环境不发生跨域，但开发环境发生跨域。

开发代理：只需要在开发环境使用代理解决跨域。

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code class="language-javascript hljs" node="[object Object]" data-highlighted="yes">module.exports = {

    devServer: { // 配置开发服务器

        proxy: { // 配置代理

            "/api": { // 若请求路径以 /api 开头

                target: "http://dev.taobao.com", // 将其转发到 http://dev.taobao.com
            },
        },
    },
}
</code></div></pre>

**nginx 代理**

反向代理功能是nginx的三大主要功能之一（静态web服务器、反向代理、负载均衡）。

反向代理：帮服务器拿到数据，然后选择合适的服务器。

和CORS原理同，需要配置请求响应头Access-Control-Allow-Origin等字段。

**怎么做反向代理与负载均衡**

Nginx作为反向代理服务器，就是把http请求转发到另一个或者一些服务器上。通过把本地一个url前缀映射到要跨域访问的web服务器上，就可以实现跨域访问。

对于浏览器来说，访问的就是同源服务器上的一个url。

而Nginx通过检测url前缀，把http请求转发到后面真实的物理服务器。

并通过rewrite命令把前缀再去掉。这样真实的服务器就可以正确处理请求，并且并不知道这个请求是来自代理服务器的。

> 正向代理就是冒充客户端，反向代理就是冒充服务端。

**WebSocket 协议(与HTTP同级)**

因为WebSocket请求头信息中有origin字段，表示请求源自哪个域，服务器可以根据这个字段判断是否允许本次通信。

**document.domain + iframe**

原理：相同主域名不同子域名下的页面，

该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。

只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域

**location.hash + iframe**

通过C页面实现A和B通信

**window.name(共享变量) + iframe**

**使用Apache做转发**

逆向代理，让跨域变成同域。

## 输入URL回车后发生了什么

简易版

1. URL解析
2. 查找缓存
3. 域名解析：浏览器缓存>系统缓存>本地hosts>根域名>顶级域名>二级域名>三级域名
4. TCP三次握手
5. 发送HTTP请求
6. 服务器处理请求并返回报文
7. 浏览器解析渲染页面
8. TCP四次挥手 关闭TCP连接

从宏观是上理解从输入URL到页面渲染的过程,**主要分为导航阶段和渲染阶段.**

**A 导航阶段**

**一、浏览器主进程**

**1. 用户输入URL**

**1、**浏览器进程检查url，组装协议，构成完整的url，这时候有两种情况：

* 输入的是搜索内容：地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。
* 输入的是请求URL：地址栏会根据规则，给这段内容加上协议，合成为完整的URL；

**2、**浏览器进程通过进程间通信（IPC）把url请求发送给网络进程；

URL一般包括几大部分：

* protocol，协议头，譬如有http，ftp等
* host，主机域名或IP地址
* port，端口号
* path，目录路径
* query，即查询参数
* fragment，即 #后的hash值，一般用来定位到某个位置

**二、网络进程**

**2. URL请求过程**

**3、**网络进程接收到url请求后检查本地是否缓存了该请求资源。

* 浏览器发送请求前，根据请求头的expires和cache-control判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。
* 没有命中强缓存规则，浏览器会发送请求，根据请求头的If-Modified-Since(last_modified)和If-None-Match(ETag)判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。
* 如果前两步都没有命中，则直接从服务端获取资源。

**4、**准备IP地址和端口：进行DNS解析时先查找缓存，没有再使用DNS服务器解析，查找顺序为：

* 浏览器缓存；
* 本机缓存；
* hosts文件；
* 路由器缓存；
* ISP DNS缓存；
* DNS递归查询（本地DNS服务器 -> 权限DNS服务器 -> 顶级DNS服务器 -> 13台根DNS服务器）

**5、**等待TCP队列：浏览器会为每个域名最多维护6个TCP连接，如果发起一个HTTP请求时，这 6个 TCP连接都处于忙碌状态，那么这个请求就会处于排队状态，解决方案：

* 采用域名分片技术：将一个站点的资源放在多个（CDN）域名下面。
* 升级为HTTP2，就没有6个TCP连接的限制了；

**6、**通过三次握手建立TCP连接：

* 第一次：**客户端先向服务器端发送一个同步数据包，报文的TCP首部中：标志位：**同步SYN为1，表示这是一个请求建立连接的数据包；序号Seq=x，x为所传送数据的第一个字节的序号，随后进入SYN-SENT状态；

> 标志位值为1表示该标志位有效。

* **第二次：**服务器根据收到数据包的SYN标志位判断为建立连接的请求，随后返回一个确认数据包，其中标志位SYN=1，ACK=1，序号seq=y，确认号ack=x + 1表示收到了客户端传输过来的x字节数据，并希望下次从x+1个字节开始传，并进入SYN-RCVD状态；

> 这里要区分标志位ACK和确认号ack；

* **第三次：**客户端收到后，再给服务器发送一个确认数据包，**标志位ACK=1，序号seq=x+1，确认号ack=y+1，随后进入ESTABLISHED状态；**

服务器端收到后，也进入ESTABLISHED状态，由此成功建立了TCP连接，可以开始数据传送；

* **为什么要第三次挥手？**避免服务器等待造成**资源浪费** ，具体原因：

> 如果没有最后一个数据包确认（第三次握手），A先发出一个建立连接的请求数据包，由于网络原因绕远路了。A经过设定的超时时间后还未收到B的确认数据包。 于是发出第二个建立连接的请求数据包，这次网路通畅，B的确认数据包也很快就到达A。于是A与B开始传输数据； 过了一会A第一次发出的建立连接的请求数据包到达了B，B以为是再次建立连接，所以又发出一个确认数据包。由于A已经收到了一个确认数据包，所以会忽略B发来的第二个确认数据包，但是B发出确认数据包之后就要一直等待A的回复，而A永远也不会回复。 由此造成服务器资源浪费，这种情况多了B计算机可能就停止响应了。

**7、**构建并发送HTTP请求信息；

* 建立TCP连接后，在这基础上进行通信，浏览器发送http请求到目标服务器，请求的内容包括 **请求行 请求头和请求体**
* 当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完之后返回一个HTTP**响应消息，包括，响应行，响应头和响应体。**
* 服务器响应之后，现在HTTP默认开启长连接，**页面关闭后，TCP连接会经过四次挥手断开**

**8、**服务器端处理请求；

**9、**客户端处理响应，首先检查服务器响应报文的状态码：

* 如果是301/302表示服务器已更换域名需要重定向，这时网络进程会从响应头的**Location**字段里面读取重定向的地址，然后再发起新的HTTP或者HTTPS请求，跳回第4步。
* 如果是200，就检查Content-Type字段，值为text/html说明是HTML文档，是application/octet-stream说明是文件下载；

**10、**请求结束，当通用首部字段Conection不是Keep-Alive时，即不为TCP长连接时，通过四次挥手断开TCP连接：

**四次挥手步骤（抽象派）**

* 主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
* 被动方：收到通道关闭的信息
* 被动方：那我也告诉你，我这边向你的主动通道也关闭了
* 主动方：最后收到数据，之后双方无法通信
* **第一次：**客户端（主动断开连接）发送数据包给服务器，其中标志位FIN=1，序号位seq=u，并停止发送数据；
* **第二次：**服务器收到数据包后，由于还需传输数据，无法立即关闭连接，先返回一个标志位ACK=1，序号seq=v，确认号ack=u+1的数据包；
* **第三次：**服务器准备好断开连接后，返回一个数据包，其中标志位FIN=1，标志位ACK=1，序号seq=w，确认号ack=u+1；
* **第四次：**客户端收到数据包后，返回一个标志位ACK=1，序号seq=u+1，确认号ack=w+1的数据包。

由此通过四次挥手断开TCP连接。

**为什么要四次挥手？**

由于 **服务器不能马上断开连接** ，导致FIN释放连接报文与ACK确认接收报文需要分两次传输，即第二次和第三次"挥手"；

**3. 准备渲染进程**

**11、**准备渲染进程：浏览器进程检查当前url是否与之前打开了渲染进程的页面的根域名相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程；

**4. 提交文档**

**12、**提交文档：

* **渲染进程**准备好后，**浏览器**向**渲染进程**发起“ **提交文档** ”的消息，**渲染进程**接收到消息后与**网络进程**建立传输数据的“ **管道** ”
* **渲染进程**接收完数据后，向浏览器发送“ **确认提交** ”
* **浏览器进程**接收到确认消息后更新浏览器界面状态： **安全状态** 、 **地址栏url** 、 **前进后退的历史状态** 、**更新web页面**

**B 渲染阶段**

渲染步骤大致可以分为以下几步：

1. 解析HTML，构建DOM树
2. 解析CSS，生成CSS规则树
3. 合并DOM树和CSS规则，生成render树
4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
5. 绘制render树（paint），绘制页面像素信息
6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上

在渲染阶段通过**渲染流水线**在渲染进程的主线程和合成线程配合下，完成页面的渲染；

**三、渲染进程**

**5. 构建DOM树**

**13、**先将请求回来的数据解压，随后HTML解析器将其中的HTML**字节流**通过**分词器**拆分为一个个Token，然后生成节点Node，最后解析成浏览器识别的DOM树结构。[解析HTML,生成DOM树]

1. ![](https://notes.kamacoder.com/pics/_%E5%89%8D%E7%AB%AF_%E6%B5%8F%E8%A7%88%E5%99%A8_%E8%BE%B0%E4%B9%9D%E4%B9%9D.png)
2. 重点过程
3. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符
4. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集
5. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则
6. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样。例如：body对象的父节点就是HTML对象，然后段落p对象的父节点就是body对象
7. 最后DOM树

可以通过Chrome调试工具的Console选项打开控制台输入document查看DOM树；

> 渲染引擎还有一个**安全检查模块**叫 XSSAuditor，是用来**检测词法安全**的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如 **是否引用了外部脚本** ， **是否符合 CSP 规范** ，**是否存在跨站点请求**等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务 **进行拦截** 。

首次解析HTML时**渲染进程**会开启一个 **预解析线程** ，遇到HTML文档中内嵌的JavaScript和CSS外部引用就会同步提前下载这些文件，下载时间以最后下载完的文件为准。

**6. 构建CSSOM**

**14、**CSS解析器将CSS转换为浏览器能识别的styleSheets也就是CSSOM：可以通过控制台输入document.styleSheets查看；

这里要考虑一下阻塞的问题，由于JavaScript有修改CSS和HTML的能力，所以，需要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM。由于这种阻塞，导致了 **解析白屏** ；[解析CSS, 生成CSSOM]

> **优化方案：**

1. **移除js和css的文件下载** ：通过内联 JavaScript、内联 CSS；
2. **尽量减少文件大小** ：如通过 webpack 等工具**移除**不必要的 **注释** ，并 **压缩 js 文件** ；
3. 将不进行DOM操作或CSS样式修改的 JavaScript 标记上 **async 或者 defer异步引入；**
4. **使用媒体查询属性** ：将大的CSS文件拆分成多个不同用途的 CSS 文件，只有在特定的场景下才会加载特定的 CSS 文件。

可以通过浏览器调试工具的Network面板中的DOMContentLoaded查看最后生成DOM树所需的时间；

**7. 样式计算**

**15、**转换样式表中的属性值，使其标准化。**比如将em转换为px，color转换为rgb；**

**16、**计算DOM树中每个节点的具体样式，这里遵循CSS的继承和层叠规则；可以通过Chrome调试工具的Elements选项的Computed查看某一标签的最终样式；

**8. 布局阶段**

[结合DOM和CSSOM树,生成渲染树]

**17、**创建布局树，遍历DOM树中的所有节点，去掉所有隐藏的节点（比如head，添加了display:none的节点），只在布局树中保留可见的节点。

**18、**计算布局树中节点的坐标位置（较复杂，这里不展开）,对于每个可见的节点,找到CSSOM树中对应规则并应用,根据每个可见节点及其对应的样式,生成渲染树；

**9. 分层**

**19、**对布局树进行分层，并生成分层树（Layer Tree），可以通过Chrome调试工具的Layer选项查看。分层树中每一个节点都直接或间接的属于一个图层（如果一个节点没有对应的层，那么这个节点就从属于父节点的图层）

**图层**

一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。 **不同的图层渲染互不影响** ，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。**但也不能生成过多的图层，会引起反作用。**

通过以下几个常用属性可以生成新图层

* 3D 变换：translate3d、translateZ
* will-change
* video、iframe 标签
* 通过动画实现的 opacity 动画转换
* position: fixed

**10. 图层绘制**

**20、**为每个图层生成绘制列表（即绘制指令），并将其提交到合成线程。以上操作都是在渲染进程中的主线程中进行的，提交到合成线程后就不阻塞主线程了；

**11. 切分图块**

**21、**合成线程将图层切分成大小固定的图块（256x256或者512x512）然后**优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度；**

**四、GPU 进程**

**12. 栅格化操作**

**22、**在**光栅化线程池**中将**图块**转换成 **位图** ，通常这个过程都会使用GPU来加速生成，使用GPU生成位图的过程叫 **快速栅格化** ，或者GPU栅格化，生成的位图被保存在GPU内存中。

**五、浏览器主进程**

**13. 合成与显示**

**23、**合成：一旦所有图块都被光栅化，**合成线程**就会将它们合成为一张图片，并生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

> **注意了：**合成的过程是在渲染进程的**合成线程**中完成的，不会影响到渲染进程的**主线程**执行；

**24、**显示：浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。将像素发送给GPU,展示在页面上(GPU将多个合成层合并成一个层,展示)

到这里，经过这一系列的阶段，编写好的HTML、CSS、JavaScript等文件，经过浏览器就会显示出漂亮的页面了。

> Layout回流 [重排]：通过 JavaScript 或者 CSS 修改元素几何位置属性，会触发重新布局，解析后面一系列子阶段

> 重绘：跳过了布局阶段，直接进入绘制，然后再分块、生成位图及其以后子阶段；Painting 根据渲染树及回流得到的几何信息,得到节点的绝对像素.

> 合成：渲染引擎跳过布局和绘制阶段，执行的后续操作，发生在合成线程，非主线程；

## HTTP

### HTTP缓存

HTTP缓存都是在第二次请求时才开始的。

缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此节省了 **通信流量和通信时间** 。

**作用**

* 缓解压力
* 降低客户端获取资源的延迟，读取缓存速度快，地理位置可能比源服务器更近

**强缓存**

服务器与浏览器约定一个文件过期时间，向browser缓存查找该请求结果，并根据该结果的缓存规则决定是否使用该结果。**决定是否使用缓存主动性在浏览器这边.**

* 强制缓存失效，发送请求（和第一次请求一样），响应状态码为200
* 存在缓存结果和标识但结果已失效，使用协商缓存 ﻿
* **存在缓存结果和标识且未失效，直接返回结果，响应状态码为403，在 size 项中标识的是 from disk cache**

发送请求时，服务器会把缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器， 控制强制缓存的字段分别是**Expires（HTTP1.0时期使用）**

**Cache-Control（HTTP/1.1时期使用）**

**其中Cache-Control优先级比Expires高。**

**Expires(HTTP/1.0)**

存在于服务器返回的响应头。

Expires是HTTP/1.0控制网页缓存的字段，**其值为服务器返回该请求结果缓存的到期时间，**即再次发起该请求时，如果客户端的时间小于Expires的值时， 直接使用HTTP**本地缓存并返回状态码200 。**

缺点： Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。

**Cache-Control(HTTP/1.1)**

来源于响应头和请求头。

没有采用具体的过期时间节点的方式，而是采用过期时长控制缓存，对应缓存为max-age。

在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：

> public：所有内容都将被缓存（客户端和代理服务器都可缓存）
>
> private：所有内容只有客户端可以缓存，Cache-Control的默认取值
>
> **no-cache** ：跳过当前当前强缓存，客户端缓存内容，直接进入协商缓存阶段。
>
> **no-store** ：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
>
> **max-age** =xxx (xxx is numeric)：缓存内容将在xxx秒后失效， **只有http1.1可用** 。

**强缓存失效进入协商缓存。**

Cache-Control实现流程:

1. 浏览器第一次请求访问服务器资源时,服务器会在返回这个资源的同时,在response头部加上 Cache-Control, Cache-Control 中设置了过期时间大小；
2. 浏览器再次访问服务器该资源时, **会先通过请求资源的时间与cache-control中设置的过期时间对比,计算该资源是否过期** ,若没有则使用该缓存,否则重新请求资源.
3. 服务器再次收到请求后,会再次更新Response头部的Cache-Control.

 **优先级** :Cache-Control > Expires

**协商缓存**

> **协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存** ，通过服务端告知客户端是否可以使用缓存的方式称为协商缓存。

强制缓存失效后，browser携带缓存标识tag向server发请求，由服务器根据缓存tag决定是否使用缓存的过程。

tag分为两种：Last-Modified和ETag，不分上下。

**Last-Modified(HTTP/1.0)**

> **Last-Modified(响应头)，If-Modified-Since(请求头)**

 **最后一次修改时间** 。以此判断当前请求资源是否是最新的，浏览器第一次给服务器发送请求后，服务器会在响应头中加入这个字段。

browser接收后，若再次请求，会在请求头中携带If-Modified-Since字段，也就是server传来的最后修改时间。

服务器拿到**请求头**中的If-Modified-Since字段后，和服务器中该资源的最后修改时间对比：

> 若请求头中这个值小于修改时间，说明应该更新了。返回新的资源，状态码为200。 否则返回304，直接使用缓存。

**ETag(HTTP/1.1)**

**服务器**根据当前文件的内容，给文件 **页面生成的唯一标识** 。通过响应头传送给浏览器。

浏览器会在下次请求时，将这个值作为If-None-Match字段的内容，放到 **请求头** 。

使用 ETag 字段实现的协商缓存的过程如下：

* 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；
* 当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期，如果没有过期，则直接使用本地缓存；如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；
* 服务器再次收到请求后， **会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较** ：
* **如果值相等，则返回 304 Not Modified，不会返回资源** ；
* 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；
* 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。

> **ETag(响应头)、If-None-Match(请求头)**

**强ETab**

强ETag值，不论实体发生多么细微的变化都会改变其值。

**弱ETag**

弱ETag值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变ETag值。这时，会在字段值最开始处附加W/，'W/' （区分大小写）开头表示使用弱校验。

对于两个资源，强校验要求每个字节都相同才认为是同一个资源；而弱校验则把决定权交给开发者，根据需要区分的要素来生成相应的 ETag 。

为什么要区分强弱呢，因为大多数情况下，确保严格的字节级别的一致性是没有必要的。例如，如果我们开启了 HTTP 压缩，那么对于一个资源的响应，压缩前和压缩后的字节就是不一致的，但通常我们只关心压缩前的 ETag ，这时就需要使用弱校验的 ETag 。

**两者对比**

如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候， Etag 的优先级更高，也就是先会判断 Etag 是否变化了，如果 Etag 没有变化，然后再看 Last-Modified。

1. 精确度**：ETag>Last***Modified。ETag按照内容给资源上标识，可准确感知资源的变化。Last*Modified不一样

* 编辑了资源文件，但内容没改变，会造成缓存失效
* Last_Modified可感知的时间单位是s，若在1s内修改了文件，不能体现出来。

2. 性能上：Last*Modified优于Etag。Last*Modified只是记录一个时间点，ETag根据文件具体内容生成哈希值。

 **协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求** 。

### HTTP 2.0

**特性**

HTTP/2 协议基于 HTTPS

HTTP2.0可以说是SPDY的升级版本，与SPDY的区别如下：

1. HTTP2.0支持明文HTTP传输，而SPDY强制使用HTTPS。
2. HTTP2.0消息头压缩算法使用HPACK，而SPDY使用DEFLATE。

HTTP2.0主要目标是改进传输性能，实现低延迟和高吞吐量。

HTTP2.0升级改造需要考虑：

1. HTTP2.0可以支持非HTTPS，但是主流浏览器如chrome、Firefox还是只支持基于TLS部署的HTTP2.0协议，所以要升级HTTP2.0还是先升级HTTPS
2. 升级HTTPS后，如果使用NGINX，只需要在配置文件中启动相应的协议就可以
3. HTTP2.0完全兼容HTTP1.x，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容

**二进制分帧**

HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用二进制格式**，头信息和数据体都是二进制，统称为帧（frame）：**头信息帧（Headers Frame）和数据帧（Data Frame）。

对人不友好，但是对计算机非常友好，因为计算机只懂二进制，收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这**增加了数据传输的效率**

**(因为是新增的二进制分帧层，所以叫2.0)**

不改变HTTP语义，HTTP方法、状态码、URL及首部字段。**改进传输性能，实现低延迟和高吞吐量**

HTTP1.x解析基于文本，文本展现形式多样，要做到健壮性考虑的场景必然很多，二进制则只有0和1，更**高效健壮**

**首部压缩**

HTTP/2 会 **压缩头** （Header）如果同时发出多个请求，他们的头是一样的或是相似的，那么，协议会**消除重复的部分**

HPACK算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就**提高速度**

HTTP 1.x无首部压缩，Gzip只对请求体压缩

SPDY和HTTP 2.0都支持首部压缩。使头部帧最大程度复用，减少头部大小，利于减少内存和流量

比如：第一次请求，包含头部各种信息，后来又发送另外请求，发现大部分字段可以复用，一次只发送一个当前请求特有的头部帧即可

首部表在HTTP 2.0的连接存续期始终有效，server和client共同更新

避免重复header传输，又减少需要传输的大小

1. HTTP2.0会压缩首部元数据，在client和server使用首部表跟踪和存储之前发送的健值对，对于相同数据，不需每次请求响应都发送
2. 所有header必须全部小写，而且请求行要独立为健值对（即header+值）

**多路复用**

HTTP 1.0：建立连接请求数据完毕之后立即关闭连接；

后来采用keep-alive模式使得可以复用连接而不断开，可利用这次连接继续请求数据

缺点：必须等到server返回上一次的请求数据才可以进行下一次请求

Q：遇到一个请求很久没有响应，后面的请求只能等待？

HTTP/2 是可以在 **一个连接中并发多个请求或回应，而不用按照顺序一一对应** 。

 **多路复用** （MultiPlexing），即连接共享，每一个request都是用作连接共享机制的。每一个request对应一个id，一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方根据request的id将request再归属到不同服务端请求里面。客户端只需要一个连接就可以加载一个页面

移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，**降低了延迟，大幅度提高了连接的利用率**

举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分

优点：

1. 并行交错发送请求，请求之间互不影响
2. TCP连接一旦建立可并行发送请求
3. 消除不必要延迟，减少页面加载时间
4. 可最大程度利用HTTP 1.x

**请求优先级**

server根据流的优先级控制资源分配，响应数据准备好后，把优先级最高的帧发送给client。browser发现资源时立即分派请求，**指定每个流的优先级，让服务器决定最优的响应次序，这时请求不用排队，节省时间，最大限度利用连接**

**流量控制**

流：不改变协议，允许采用多种流量控制算法

特点：

1. 流量基于HTTP连接的每一跳进行，不是端到端控制
2. 流量基于窗口更新帧进行，接收方可广播准备接收字节甚至对整个连接要接收的字节数
3. 流量控制有方向，接收方根据自身情况控制窗口大小
4. 流量控制可由接收方禁用
5. 只有data帧服从流量控制，其他不会消耗控制窗口的空间

**服务端推送**

HTTP/2 在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再被动响应，也**可以主动向客户端发送消息**

server push通过推送那些它认为客户端将会需要使用到的内容到客户端缓存中，以此避免往返的延迟

1. 客户端可以限定推送流的数量，也可以设置为0而完全禁用server push
2. 所有推送遵守同源策略，即服务器不能随便将第三方资源推送给客户端，必须是经过双方确认的
3. PUSH_PROMISE帧：所有服务器推送流都通过PUSH_PROMISE发送，服务端发出有意push所述资源的信号，客户端接收到PUSH_PROMISE帧后，也可以拒绝这个流
4. 服务端必须遵循请求-响应的循环，只能借着对请求的响应推送资源。
5. PUSH_PROMISE帧必须在返回响应之前发送，否则客户端会出现竞态条件。

**数据流**

HTTP/2 的数据包不是按顺序发送，同一个连接里面连续的数据包，可能属于不同回应。因此，必须要对数据包做标记，指出它属于哪个回应

在 HTTP/2 中每个请求或相应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号（Stream ID）， **不同 Stream 的帧可以乱序发送（因此可以并发不同Stream ）** ，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息

客户端和服务器 **双方都可以建立 Stream** ， Stream ID 也有区别，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号

客户端还可以 **指定数据流的优先级** 。优先级高的请求，服务器就先响应该请求。

**缺陷**

HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。

**HTTP/2 是基于 TCP 协议传输数据，TCP 是字节流协议，TCP 层必须保证收到的字节数据完整且连续，这样内核才会将缓冲区里的数据返回给 HTTP 应用，当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据—— HTTP/2 队头阻塞问题。**

![](https://notes.kamacoder.com/pics/_JS_HTTP2.0_%E8%BE%B0%E4%B9%9D%E4%B9%9D.png)

图中发送方发送了很多个 packet，每个 packet 都有自己的序号，可以认为是 TCP 的序列号，其中 packet 3 在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 TCP 数据不连续，于是接收方的应用层无法从内核中读取，只有等到 packet 3 重传后，接收方的应用层才可以从内核中读取到数据——HTTP/2 的队头阻塞问题，发生在 TCP 层面

所以，一旦发生了丢包现象，就会触发 TCP 重传机制，这样在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**

## 浏览器存储

### 前端缓存

前端缓存技术方法主要分为http缓存和浏览器缓存。

* HTTP缓存：强缓存、协商缓存
* 浏览器缓存：storage 前端数据库和应用缓存

应用缓存主要是通过manifest文件来注册被缓存的静态资源，已经被废弃，因为它的设计有些不合理的地方，在缓存静态文件的同时，会默认缓存html文件。这导致页面的更新只能通过manifest文件中的版本号来决定。所以，应用缓存只适合那种常年不变化的静态网站。如此不方便，是被废弃的重要原因。

对于一些具有重复性的HTTP请求,比如每次请求得到的数据都是一样的,我们可以把这对[请求-响应]的数据都缓存在本地,下次就直接读取本地数据,不必再通过网络获得服务器的响应了,这样可以大大提升网络性能。

浏览器对服务器最近请求过的资源进行存储，减少与服务器的交互，减少对宽带浪费，减少服务器负担。分为强缓存和协商缓存。

HTTP控制缓存的字段主要包括Cache-Control/Pragma,Expires,Last-Modified/Etag。

**本地强缓存如果过期了，就需要协商缓存，也就是去看服务器上的资源是否修改。**

### 缓存存储

* 内存缓存：快速读取和实效性
* 硬盘缓存：写入硬盘文件，需要I/O操作，重新解析改缓存内容，读取复杂，速度慢

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

* Service Worker
* Memory Cache
* Disk Cache
* Push Cache

大的JS 、CSS文件直接丢进磁盘，反之丢进内存

内存使用率高时，文件优先进入磁盘

### Cookie

调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他Web 站点和攻击者的攻击而泄露

**Set-Cookie**

当服务器准备开始管理客户端的状态时，会事先告知各种信息。

> Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path

cookie字段

* name = value 如果用于保存用户登录态，赋值 cookie 的名称和值expires=datecookie有效期path=path将服务器上的文件目录作为cookie的使用对象domain=域名cookie适用对象的域名HttpOnly不能通过 JS 访问 Cookie，减少 XSS 攻击secure只能在协议为 HTTPS 的请求中携带same-site规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击
* **expires**

指定 Cookie 的有效期。省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内

* **domain**

表示cookie作用域

比如，当指定 .example.com 后，除 .example.com 以外， [www.example.com](http://www.example.com/)或 www2.example.com等子域名都可以访问Cookie

* **secure**

限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie

Set-Cookie: name=value; secure

以上例子仅当在[https://www.example.com/（HTTPS）安全连接的情况下才会进行Cookie](https://www.example.com/%EF%BC%88HTTPS%EF%BC%89%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%89%8D%E4%BC%9A%E8%BF%9B%E8%A1%8CCookie) 的回收

当省略 secure 属性时，不论 HTTP还是 HTTPS，都会对 Cookie 进行回收

* **HttpOnly**

禁止JS脚本访问 Cookie

Set-Cookie: name=value; HttpOnly

使用 JavaScript 的 document.cookie 无法读取Cookie的内容。 因此，也就无法在 XSS 中利用 JavaScript 劫持Cookie

* **SameSite**

是否允许跨域时携带Cookie

strict：任何情况都不允许作为第三方cookie

Lax：宽松模式，只能在请求方法为Get且请求改变了当前页面或打开新的页面时，允许cookie跨域访问

None：默认模式，请求自动携带cookie

**Cookie 请求首部字段**

告知服务器，当客户端想获得 HTTP状态管理支持时， 就会在请求中包含从服务器接收到的 Cookie。 接收到多个Cookie 时，同样可以以多个 Cookie形式发送。

Cookie: status=enable

**禁止js访问cookie**

设置HttpOnly

JS [Document.cookie](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie)API 无法访问cookie

**JS设置cookie**

**[document.cookie](http://document.cookie/)** 属性来创建 、读取、及删除 cookie

创建 cookie ：

document.cookie="username=John Doe";

添加一个过期时间（默认cookie 在浏览器关闭时删除：

document.cookie="username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT";

使用 path 参数告诉浏览器 cookie 的路径。默认，cookie 属于当前页面

document.cookie="username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/";

读取

var x= document.cookie; //以字符串方式返回所有cookie

**cookie作用域**

domain本身以及domain下的所有子域名

**跨域请求访问cookie**

1. cookie不能跨根域，但JS可以，JS可以将cookie传给另外的域再保存一次域名cookie，这样可能存在不同的cookie域包含同一个cookie值
2. browser不允许跨根域读写
3. 采用SSO单点登录方式

**没有cookie会出现什么问题？**

cookie：解决 如何记录客户端用户信息 的问题。保存在本地的一部分数据，再次发送请求被携带传送到服务器，通知server是否请求来自统一状态浏览器，如保持用户登录

使基于无HTTP协议记录的信息状态稳定成为可能

作用：

1. 会话状态
2. 个性化设置
3. 浏览器行为跟踪

### 鉴权

**Cookie**

服务端响应客户端请求时，会返回一个cookie，后续客户端的请求携带这个cookie

特点

1. 存储在客户端，可随意纂改
2. 影响性能，最大为4kb
3. 一个浏览器对于一个网站只能存不超过20个Cookie，而浏览器一般只允许存放300个Cookie
4. 移动端对Cookie支持不友好
5. 一般情况下存储的是纯文本，对象需要序列化之后才可以存储，解析需要反序列化

通过设置正确的domain和path，减少数据传输，节省带宽

**Cookie-session**

cookie需要的存的东西越来越多，但是cookie大小有限制

所以后端返回sessionId，客户端将sessionid存在cookie中

缓存数据库：所有机器根据sessionId去缓存系统获取用户信息和认证

局限性

1. 依赖Cookie，但Cookie可被禁用
2. 系统不停请求缓存服务器查找信息，内存开销增加
3. 存在单点登录失败的可能性

> 若负责session的机器挂了，整个登录就挂了，但项目中，负责session的机器也是有多台机器的集群进行负载均衡增加可靠性

**SSO**

（单点登录）三种类型

Single Sign On 在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统

单点登录

1. 同一站点下
2. 相同的顶级域名
3. 不同的顶级域名

相同域名和相同顶级域名下可共享cookie

但是不同域呢？

* CAS（中央认证服务）原理
* 流程和Cookie-session模式相同

**Json Web Token**

> 最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+哈希算法压缩成一定长的十六进制字符串，防止恶意三方拼接token请求)

JWT由header（头部）、payload（负载）、signature（签名）这三个部分组成，中间用.来分隔开：Header.Payload.Signature

> jwt: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOiJhIiwiaWF0IjoxNTUxOTUxOTk4fQ.2jf3kl_uKWRkwjOP6uQRJFqMlwSABcgqqcJofFH5XCo"

* 弊端

1. JWT的退出是假的登录失效，只要之前的token没过期依然可以用
2. 安全性依赖密钥
3. 加密生成的数据长

* 优点

1. 不依赖Cookie
2. 没有单点登录的cookie-sessionId模式好扩展
3. 服务器保持无状态性

session 和 token 的对比就是「用不用cookie」和「后端存不存」的对比

### Webstorage

克服cookie带来的限制，不需要持续将数据返回server。

1. 提供cookie之外的存储会话数据的路径
2. 可以用来跨网站/应用 检测用户的行为而不需要服务端脚本和数据库
3. 拥有在用户即使突然断网的情况下保存部分web应用的能力，不会让你因为网络连接问题受到影响
4. 和cookie一样存在跨域策略

**分类**

**localStorage**

(针对同一个域名)

特点：

1. 生命周期：持久化的本地存储，除非手动删除数据，否则数据是永远不会过期的
2. 存储的信息在同一域中共享
3. 大小：5M，和浏览器厂商有关
4. 本质上是对字符串的读取，若存储内容过多会消耗内存空间，导致页面卡顿
5. 受同源策略限制

缺点

1.无法像cookie一样设置过期时间

2.只能存入字符串，无法直接存储对象

**sessionStorage**

和localStorage相似，**唯一不同就是生命周期，一旦页面关闭，sessionStorage将会删除数据**

**相同点**

1. **存储大小：一般都是5MB**
2. 存储位置：都存在客户端
3. 存储内容类型：只能存储字符串类型
4. 获取方式：window.localStorage
5. 应用：localStorage用于长期登录，适合长期保存在本地的数据。sessionStorage用于敏感账号一次性登录。
6. 接口封装

**优点**

1. 存储空间大
2. 节省网络流量
3. 快速显示
4. 安全性
5. 对于那种只需要短暂存储关闭页面就可以丢弃的数据，sessionStorage很好用

**方法**

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code class="language-javascript hljs" node="[object Object]" data-highlighted="yes">setItem(key,value) //保存

getItem(key) //获取

key() //获取键名

removeItem(key) //清除

clear() //清除所有数据

key(index) //获取索引的key
</code></div></pre>

**IndexedDB**

Indexed Database API（IndexedDB）

前端数据库有WebSql和IndexDB，其中WebSql被规范废弃，他们都有大约50MB的最大容量，可以理解为localStorage的加强版。

扩展的前端存储方式，是运行在浏览器中的非关系型数据库，理论上容量无上限。

**特性**

1. 储存量理论上没有上限
2. 所有操作都是异步的，相比 LocalStorage 同步操作性能更高，尤其是数据量较大时
3. 原生支持储存JS的对象
4. 是个正经的数据库，意味着数据库能干的事它都能干
5. 同源策略限制
6. 操作繁琐

## 浏览器执行机制

### 关于一段代码执行前的“编译”

**一、编译语言和解释语言**

我们写的代码一般不能被电脑直接识别，所以就有了编译器和解释器，也对应不同的语言

编译语言一般是 C / C++， Go等，这类语言首次执行会通过编译器编译出机器能读懂的二进制文件，每次运行的时候会直接运行这个二进制文件。

解释语言一般是Python，JavaScript等，每次执行都需要解释器进行动态解释和执行。

**二、编译的过程**

那么编译一般来说有六个步骤

1. **分词 / 词法分析** a. 把字符组成的字符串分解成有意义的代码块（词法单元）， 如 var a = 2，会分解为 var ， a， =，2；
2. **解析 / 语法分析** a. 将上面的词法单元流（数组）转换为由元素逐级嵌套所组成的代表程序语法结构的树，也就是AST
3. **生成抽象语法树（AST）**
4. **词义分析**
5. **生成二进制文件或者字节码**
6. **执行**

编译语言和解释语言的主要区别在于词义分析后生成的类型不同，他们都会生成AST这一步，3,4,5，6可以合并称之为代码生成

我们前端开发用的JavaScript就是解释型语言，其实一开始是没有字节码的，是直接将AST编译成机器码，所以效率是很高的，但是机器码占用的内存过大，所以又有了字节码的出现。这里又涉及到一门新的技术 JIT （即使编译）的出现。

所以我们的V8引擎使用的是 字节码 + JIT 的技术

### AST 抽象语法树

首先我们知道我们输入一段 JavaScript 代码，他会先经过词法和语法分析得到 AST 也就是我们的抽象语法树。那么为什么需要转化为 AST 呢？那是我们编写的的的无论是编译型语言还是解释型语言，都是不能被编译器或解释器所理解的。而且转化为 AST 还能有很多的便利，我们的 babel ， ESlint 很多工具都是在这一步进行的。

**1. 首先第一步是分词，也就是词法分析**

分词就是把一行行代码拆分为每一个 token ，也就是 语法上不可再分，最小的单位。同时去除空格，对 token 分类等。

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code class="language-javascript hljs" node="[object Object]" data-highlighted="yes">// 源码
let aaa = '12: 30'

// Tokens数组
[
  { type: { ... }, value: "let", start: 0, end: 3, loc: { ... } },
  { type: { ... }, value: "aaa", start: 4, end: 7, loc: { ... } },
  { type: { ... }, value: "=", start: 8, end: 9, loc: { ... } },
  { type: { ... }, value: "12:30", start: 10, end: 15, loc: { ... } },
]
</code></div></pre>

上面的代码就会拆分为，其中关键字“let”、标识符“aaa” 、赋值运算符“=”、字符串“12: 30”四个都是 token，而且它们代表的属性还不一样。添加到 Token 数组中。

**2. 词法分析之后就进行解析，也就是语法分析** 其作用是将上一步生成的 token 数据，根据语法规则（扫描 token 列表，形成语法二叉树）转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。

通过这样就构建起 AST 抽象语法树。

### LHS 和 RHS

首先变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（之前没有声明），然后运行时引擎会在该作用域中查找该变量，如果能找到就会对他赋值

那么引擎查找中就涉及到我们这里要讲到的 LHS查询 和 RHS查询

这里我们不能简单的认为是左右来判断，而是根据：

`LHS`：赋值操作的目标是谁 `RHS`：谁是赋值操作的源头

也可以说查找的目的是对变量进行赋值，那么就会使用LHS 查询；如果目的是获取变量的值，就会使用RHS 查询

考虑以下代码：

> console.log(a);

其中对a 的引用是一个RHS 引用，因为这里a 并没有赋予任何值。相应地，需要查找并取得a 的值，这样才能将值传递给console.log(…)

相比之下，例如：

> a = 2;

这里对a 的引用则是LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为=2 这个赋值操作找到一个目标。

看个例子

> function foo(a) { //LhS console.log(a) //RHS } foo(2) //RHS

这里面就涉及到两种查询了

同时 LHS 和 RHS 会现在当前的作用域查询，没有找到的话就会到上一层查找，最后到全局作用域

## 性能优化

1. 网站打开速度
2. 动画流畅
3. 表单提交速度
4. 列表滚动页面切换是否卡顿

**优化手法**

1. 聚焦用户
2. 尽快响应用户输入
3. 动画执行流畅
4. 最大化主线程空闲时间
5. 网页可交互性

### HTML

1. 避免HTML中直接写CSS
2. viewport加速页面渲染
3. 使用语义化标签
4. 减少标签的使用，DOM解析是一个大量遍历的过程
5. 避免src和href空值
6. 减少DNS查询数

### CSS

1. 避免后代选择符
2. 避免链式~
3. 避免!important
4. link代替@import

@import会将请求变得 串行化，导致加载增加延迟

1. 减少回流与重绘
2. CSS 放在 head 中
3. 压缩CSS 开启gzip压缩
4. 骨架屏+合理的loading
5. 优化选择器路径，避免 过多嵌套
6. 选择器合并：压缩空间和资源开销
7. 精确样式

比如设置{padding-left:10px}的值，避免{padding:0 0 0 10px}这样的写法

1. 异步加载CSS
2. 避免通配符

.a .b *{} 像这样的选择器，从右到左解析，在解析过程中遇到通配符（**）会去遍历整个dom

1. 少用float：渲染时计算量大
2. 0值不加单位：兼容性
3. 避免使用 昂贵 的属性

因为他们渲染成本挺高，渲染速度慢一些

1. border-radius
2. box-shadow
3. opacity
4. transform
5. filter
6. position: fixed
7. 使用先进布局方式——flex

**会造成阻塞吗**

1. CSS加载不会阻塞DOM树解析
2. CSS加载会阻塞DOM树渲染
3. CSS加载会阻塞后面JS执行

### JS

1. 避免循环操作DOM
2. 事件委托

绑定事件时，不绑定到目标元素上，而是绑定到其祖先元素上

1. 监听事件少
2. 新增节点时，无需增加事件绑定
3. scrip标签放在body后

CSS放在

因为JS阻塞DOM的构建(因为DOM解析遇到JS会停止解析，开始下载脚本并执行) ，CSSOM的构建阻塞JS执行

1. 压缩文件
2. 按需加载
3. 避免逐个操作DOM样式，尽可能预留好CSS样式，通过样式名的修改改变DOM样式，集中式操作减少reflow的次数
4. 减少iframe数量

**合成**

1. 合成层的位图 交由GPU处理，比CPU块
2. repaint本身，不影响其它层
3. transform和opacity不触发重绘

**代码问题**

1. 频繁使用[JSON.parse/JSON.stringify](http://json.parse/JSON.stringify)大对象
2. 正则灾难性回溯
3. 内存泄漏

### 网络相关

#### **DNS预解析**

预先获得域名所对应的 IP，href的值是预解析的域名

preload和prefetch

preload强制浏览器立即获取资源， 具有较高优先级

prefetch的资源获取时可选 和 较低 优先级的，是否获取取决于浏览器

#### **缓存**

强缓存

协商缓存

选择合适缓存策略

对于大部分的场景都可以使用强缓存配合协商缓存解决

1. 使用 Cache-control: no-store ，表示该资源不需要缓存
2. 使用 Cache-Control: no-cache 并配合 ETag ，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新
3. 使用 Cache-Control: max-age=31536000 并配合策略缓存使用，对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件

#### **使用HTTP2.0**

1. 解析速度快
2. 头部压缩
3. 多路复用
4. 服务器推送
5. 浏览器由并发请求限制

#### **预加载**

1. 有些资源不需要马上用到，但希望尽早获取
2. 预加载强制请求资源，不会阻塞 onload 事件

#### **预渲染**

将下载的文件预先在后台渲染

预渲染可以提高页面的加载速度，但是要确保该页面百分百会被用户，否则白白浪费资源

#### **减少HTTP请求**

**使用服务端渲染**

SSR （service side render）

**Gzip压缩**

**避免重定向**

### 渲染优化

**懒执行**

将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。

**懒加载**

将不关键的资源延后加载——尽量只加载用户正 浏览 或即将会 浏览的图片

只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西

对于图片来说，先设置图片标签的 src 属性为一张占位图，真实的图片资源放入自定义属性data-src 中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样就会下载图片资源

**节流防抖**

防抖：单位时间内多次触发，只执行最后的那一次，原理：延迟执行，期间但凡有新的触发就重置定时器

节流：单位时间只触发一次，原理：上锁，只有满足一定间隔时间才能执行

### 图片

电商类项目，存在大量图片，banner 广告图、菜单导航栏、列表头图等

图片众多以及体积过大影响页面加载速度

为啥？

有些图片请求并发，Chrome最多支持并发请求数有限，其他请求被push进队列中等待或停滞，直到上轮请求完成后才被发出，一部分资源需要排队等待时间，过多的图片影响页面加载展示

**合适图片格式**

1. WebP 格式具有更好的图像数据压缩算法，更小的图片体积，拥有肉眼识别无差异的图像质量，缺点是兼容性并不好
2. 小图使用 PNG，对于大部分图标，完全可以使用 SVG 代替
3. 照片使用 JPEG
4. 雪碧图( 将多个图标文件整合到一张图片中 )

可能请求非常多的小图片，会受到浏览器并发 HTTP 请求数的限制

1. 图片压缩
2. 不用图片，用CSS代替
3. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片

**JPEG/JPG**

1. **高质量 有损压缩，体积小，不支持透明**
2. 应用于轮播图 大的背景图、banner

**PNG**

1. **无损压缩，质量好，体积大，支持透明**
2. **应用小的logo**

**SVG**

1. 体积小，不失真，兼容好
2. 应用于图标

**GIF**

1. 支持透明

**Webp**

有损压缩与无损压缩（可逆压缩）的图片文件格式

比PNG/JPEG格式小

支持透明度

体积和效果上都做的不错

<pre><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="rounded p-1 text-2xl hover:bg-gray-200" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></svg><code node="[object Object]" data-highlighted="yes" class="hljs language-abnf"><picture>
    <source type="image/webp" srcset="/static/img/perf.webp">
    <source type="image/jpeg" srcset="/static/img/perf.jpg">
    <img src="/static/img/perf.jpg">
</picture>
</code></div></pre>

**webpack压缩**

配置 image-webpack-loader

**雪碧图**

CSS Sprites ，精灵图，图像合成技术，主要用于小图片显示

同原域名请求有最大并发限制，Chrome为6个，如 页面有10个小图，需要10次请求，2次并发

若把10个图合成一个大图，只需1次请求

1. 减少请求次数
2. 减少服务器压力
3. 减少并发
4. 提高加载速度
5. 减少鼠标滑过的一些bug
6. 解决网页设计师在图片命名上的困扰

**iconfont**

通过字体方式展示图标，用户 图标渲染、简单图形、特殊字体等

1. 轻量，已修改
2. 减少请求次数

**内联Base 64**

图片转为base64串，解析图片不会请求下载，而是解析字符串

缺点

1. 比使用二进制体积增大 33%
2. 全部内联后，原本可并行加载的图片会串行放入请求

适用于 更新频率低、首屏或骨架图上的小图标

**CSS代替图**

实现修饰效果，半透明、阴影、圆角、渐变等

### CDN图片

**图片懒加载**

暂时不设置图片的src属性，先卸载data-src中，等图片到了可视区域再将真实src放进src属性

使用background-url，应用到具体元素时，才会下载图片

**图片预加载**

需要展示大量图，将图提前加载到本地缓存

**响应式图加载**

在不同分辨率的设备上显示不同尺寸的图

**渐进式图片**

和骨架屏 原理类似

在图完全加载完前先显示低画质版本，让用户产生图片加载变快的印象，而不是盯着一片空白

### 其他文件优化

1. 服务端开启文件压缩功能
2. 执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以使用 Webworker

webWorker是运行在后台的JS，另开一个子线程，不会影响性能

### CDN

内容分发网络

静态资源使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名

### 其他

**使用 Webpack 优化**

1. 对于 Webpack，打包项目使用 production 模式，会自动开启代码压缩
2. ES6 模块开启 tree shaking，移除没有使用的代码
3. 优化图片，对于小图使用 base64 的方式写入文件
4. 按照路由拆分代码，实现按需加载
5. 给打包出来的文件名添加哈希，实现浏览器缓存文件

**监控**

采集——>上传——>分析——>报警

**渲染几万条数据不卡?**

通过 requestAnimationFrame 来每 16 ms 刷新一次。

### SPA首屏优化

浏览器从响应用户输入网址地址，到首屏内容渲染完成时间，整个网页不一定要完全渲染完成，但需要展示当前视窗内容

**加载慢的原因**

1. 网络延时
2. 资源文件体积过大
3. 资源加载重复发送请求
4. 加载脚本时，渲染内容阻塞

**解决**

1. 减少入口文件体积
2. 静态资源本地缓存
3. UI框架按需加载
4. 图片资源压缩
5. 组件重复打包
6. 开启GZip压缩
7. 使用SSR

**减少入口文件体积**

路由懒加载，将不同路由对应组件分割成不同代码块，待路由被请求时单独打包路由，使得入口文件变小

以函数形式动态加载路由，可以把各自的路由文件分别打包，只在解析给定路由时，才会加载路由组件

**静态资源本地缓存**

HTTP缓存和localStorage

**按需加载**

对UI库按需引用

**图片资源压缩**

对icon，使用在线字体图标

**组件重复打包**

若A.js是一个常用库，多个路由使用它会造成重复下载

在webpack的config中，修改CommonChunkPlugin的配置

minChunks为3表示会把使用3次及以上的包抽离，放进公共依赖文件

**使用SSR**

服务端渲染，Server Side ，组件或页面通过服务器生成html字符串，发送到浏览器

### 降低APP首页开屏渲染时间

1. 二次启动时先利用缓存渲染，后台进行异步数据更新
2. 减少不必要的请求 和数据获取
3. 提前请求或减少http请求
4. 优化图片文件尺寸，压缩图片格式，压缩代码
5. 启用gzip 压缩功能
6. 使用CDN
7. **网址后面加上“/”** :对服务器而言，不加斜杠服务器会多一次判断的过程，加斜杠就会直接返回网站设置的存放在网站根目录下的默认页面。
8. Ajax采用缓存调用

### 页面白屏

网络请求，返回状态

组件样式布局，组价未显示

### 网页卡顿原因

1. 网络请求是否过多，导致数据传输变慢，可通过缓存优化
2. 资源bundle太大，考虑拆分
3. 代码是否有太多循环在主线程上花费太长时间
4. 浏览器某个帧 中 渲染太多东西
5. 页面渲染时，大量回流和重绘
6. 内存泄露

### 动画性能优化

1. 合理布局
2. transform代替left、top 减少重排
3. 硬件加速
4. 避免不必要的图形层
5. requestAnimationFrame实现动画

动画每一帧都是re-render，显示器刷新频率 60 HZ，意味着每一帧任务耗时不超过 16ms

## 前端安全

### XSS和CSRF攻击

**XSS跨站脚本攻击**

Cross Site Scripting 为了和 CSS 区别，CSS 指的是层叠样式表 (Cascading Style Sheets)

用户输入或使用其他方式向代码中注入其他JS，然后JS代码被执行。

1. 可能是写一个死循环、获取cookie登录
2. 监听用户行为
3. 修改DOM伪造登录表单
4. 页面生成浮窗广告

**反射型**

XSS代码 **通过URL注入** 。

因为恶意脚本通过作为网络请求的参数，经过服务器，然后反射到HTML文档中执行解析，服务器不会存储这些恶意脚本。

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

**存储型**

XSS代码发送到 **服务器数据库** ，前端请求数据时，将XSS代码发送到前端。

场景：留言区提交一段脚本执行，若前后端未做好转义的工作，评论内容存在数据库，页面渲染过程中直接执行，相当于是执行一段未知逻辑的JS代码。

如论坛发帖、商品评论、用户私信等。

**文档型**

XSS攻击不会经过服务端，作为中间人的角色，数据传输过程劫持到网络数据包，**然后修改里面的HTML文档。**

劫持包括：

1. WIFI路由劫持
2. 本地恶意软件

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

**防范：一个信念，两个利用**

**1.对输入转码过滤**

**2.利用CSP**

浏览器内容安全策略，核心就是服务器决定浏览器加载哪些资源，功能：

1. 限制其他域下的资源加载
2. 禁止向其它域提交数据
3. 提供上报机制

**3.HttpOnly**

HttpOnly类型的cookie阻止JS对其的访问(标记或授权对话)

阻止 XSS 攻击：服务器对脚本进行过滤或转码，利用 CSP 策略，使用 HttpOnly；

**CSRF-跨站伪造请求（钓鱼）**

**Cross-Site Request Forgery**

攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证（比如cookie） ，绕过后台的用户验证，因此可以冒充用户对被攻击的网站执行某项操作。

利用所在网站的目前登录信息，悄悄提交各种信息，比XSS更恶劣。

> **本质：利用cookie会在同源请求中携带发送给服务器的特点，以此冒充用户。**

利用服务器的验证漏洞和用户之前的登录状态模拟用户操作。

点击链接后，可能发生3件事

1. 自动发送GET请求。利用src发送请求
2. 自动发送POST请求
3. 诱导点击发送GET请求

**防范**

**1.SameSite**

SameSite可以设置为三个值，Strict、Lax和None。

**a.** 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。

**b.** 在Lax模式，宽松一点，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。

**c.** 在None模式下，也就是默认模式，请求会自动携带上 Cookie。

**2.验证来源站点**

请求头中的origin和referer

origin只包含域名信息，referer包含具体的URL路径。

**3.CSRF Roken**

利用token（后端生成的一个唯一登陆态，传给前端保存）每次前端请求都会带token，后端检验通过才同意请求。

* 敏感操作需要确认
* 敏感信息的cookie只能有较短的生命周期

**4.安全框架**

如Spring Security。

**SQL注入攻击**

Sql 注入攻击，将恶意的 Sql查询或添加语句插入到应用的输入参数中，再在后台 Sql服务器上解析执行。

如何让Web服务器执行攻击者的SQL语句？

SQL注入的常规操作就是将有毒的SQL语句放置于Form表单或请求参数之中，然后提交到后端服务器，如果后端服务器没有做输入安全检查，直接将变量取出执行SQL语句，就容易中招。

预防方式如下：

* 严格检查输入变量的类型和格式
* 过滤和转义特殊字符
* 对访问数据库的Web应用程序采用Web应用防火墙

其他种类的攻击：

DDoS全称Distributed Denial of Service：分布式拒绝服务攻击。是拒绝服务攻击的升级版。拒绝攻击服务顾名思义，让服务不可用。常用于攻击对外提供服务的服务器，像常见的：

* Web服务
* 邮件服务
* DNS服务
* 即时通讯服务

DNS劫持

JSON劫持

暴力破解

HTTP报头追踪漏洞

信息泄露

目录遍历漏洞

命令执行漏洞

文件上传漏洞等等

### HTTPS中间人攻击

客户端和服务器之间的桥梁、双向获取并且篡改信息

**标准回答**

攻击者通过与客户端和客户端的目标服务器同时建立连接，作为客户端和服务器的桥梁，处理双方的数据，整个会话期间的内容几乎完全被攻击者控制。攻击者可以拦截双方的会话并且插入新的数据内容

**加分回答**

中间人攻击的过程：

1. 本地请求被劫持，所有请求均发送到中间人服务器
2. 中间人服务器返回中间人自己的证书
3. 客户端创建随机数，通过中间人证书中的公钥加密 传送给中间人，凭随机数构造对称加密对传输内容加密传输
4. 中间人拥有客户端返回的随机数，可以对内容解密
5. 中间人以客户端的请求内容向真的服务器发送请求
6. 服务器通过建立的通道返回加密后的数据
7. 中间人对加密算法内容解密
8. 中间人对内容加密传输
9. 客户端通过和中间人建立的对称加密算法对返回数据解密

缺少证书的验证，客户端完全不知道自己的网络被拦截，数据被中间人窃取

## CDN

**Content Delivery Network，内容分发网络**

我们访问一个页面的时候，会请求很多资源，包括各种图片、声音、影片、文字等信息。这和我们要购买多种货物一样

网站可以预先把内容分发至全国各地的加速节点。用户可以就近获取内容，避免网络拥堵、地域、运营商等因素带来的访问延迟问题

"内容分发网络"像前面提到的"全国仓配网络"，解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景

用户可就近取得所需内容，解决 Internet网络拥挤的状况

CDN本质 是一大堆遍布在全球各个 角落 的缓存服务器。通过与DNS的配合，找到最靠近用户的一台CDN缓存服务器，将数据快速 分发 给用户

减少对整体骨干网的流量负担，提高用户体验

DNS解析之后，浏览器向服务器请求内容后发生

长途骨干网的传输最耗时，需经过网站服务器所在的机房、骨干网、用户所在城局域网、用户所在接入网等，物理传输距离遥远

1亿人同时请求12306上一张一模一样的图片，对国家的互联网基础设施是一个灾难

CDN 提前把数据存在离用户最近的数据节点，避免长途跋涉经过长途骨干网，最终 减少骨干网负担、提高访问速度

请求图片数据，先去CDN缓存服务器获取，若获取到数据直接返回，否则才 经过 长途骨干网，最终达到 网站服务器 获取数据

CDN其实还缩短了请求数据的距离

用户分布全国各地，一般会在 离用户在 较近的地方设置 CDN 缓存服务器，酱紫各个 地区的用户能直接请求对应的CDN服务器，不需要来回跑 大半个 中国！

**过程**

1. 发起请求，本地 DNS 解析，将域名解析权交给域名 CNAME 指向的 CDN 专用 DNS 服务器
2. CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回浏览器
3. 浏览器向 CDN 全局负载均衡设备发起 URL 请求
4. CDN 全局负载均衡设备根据用户 IP ，以及URL，选择一台用户所属区域的区域负载均衡设备，向其发请求
5. 区域负载均衡设备为用户选最合适的 CDN 缓存服务器（考虑的依据包括：服务器负载情况，距离用户的距离等），返回给全局负载均衡设备
6. 全局负载均衡设备将选中的 CDN 缓存服务器 IP 返回给用户
7. 根据用户IP，判断最近边缘节点
8. 根据用户请求URL中内容，判断有用户所需内容的边缘节点
9. 查询边缘节点负载情况，判断有服务能力的边缘节点
10. 全局负载均衡设备将服务器IP返回给用户
11. 用户向 CDN 缓存服务器发起请求，缓存服务器响应用户请求，最终将内容返回

**组成**

（CDN）由多个节点组成。一般，CDN网络主要由中心节点、边缘节点两部分构成

中心节点

中心节点包括CDN网管中心和全局负载均衡DNS重定向解析系统，负责整个CDN网络的分发及管理

边缘节点

CDN边缘节点主要指异地分发节点，有负载均衡设备、高速缓存服务器两部分

负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点 工作效率；同时负责收集节点与周围环境的信息，保持与全局负载均衡DNS的通信，实现整个系统的负载均衡

高速缓存服务器（Cache）负责存储客户网站信息，像一个靠近用户的网站服务器一样响应本地用户的请求

通过全局负载均衡DNS的控制，用户的请求被透明 指向离他最近的节点，节点中Cache服务器像网站的原始服务器一样，响应终端用户的请求

**中心节点像仓配网络中负责货物调配的总仓，边缘节点就是负责存储货物的各个城市的本地仓库**

## Web Worker

JS采用单线程模型，前面任务没做完 后面的任务只能等着

webworker为JS创造多线程环境，允许主线程创建worker线程，将一些任务分配给后者运行，主线程运行的同时，worker线程在后台，互不干扰，worker完成计算任务 将结果返回 主线程

好处：计算密集型/高延迟的任务 由worker负担，主线程流畅

worker线程一旦创建 ，始终运行，不会被主线程上的活动打断，有利响应主线程的通信，缺点：worker消耗资源，不该过度使用

**注意**

1. 同源限制
2. DOM限制
3. 无法读取主线程所在网页的DOM对象，但可读navigator/location对象
4. worker线程和主线程不在同一个上下文环境，不能直接通信
5. worker不能执行alert()/confirm()，但可以发出Ajax请求

## Service Worker

> Service workers 本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。旨在创建有效的离线体验，拦截网络请求并基于网络是否可用，以及更新的资源是否驻留，在服务器上来采取适当的动作。还允许访问推送通知和后台同步 API。

运行在浏览器背后的独立线程， 通常用来做缓存文件，提高首屏速度 。

不仅仅是cache，还通过worker的方式进一步优化，基于H5的web worker，所以不会阻塞当前JS线程的执行。

SW最重要的是

1. 后台线程：独立于当前网络线程
2. 网络代理：在网页发起请求时代理，缓存文件

使用Service Worker的话，传输协议必须是HTTPS。因为Service Worker中涉及到请求拦截，所以必须使用HTTPS协议保障安全。它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker中获取的内容。

**Memory Cache**

Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭Tab页面，内存中的缓存也就被释放了。

那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？ 这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。

**Disk Cache**

Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。

**Push Cache**

Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

1. 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差
2. 可以推送 no-cache 和 no-store 的资源
3. 一旦连接被关闭，Push Cache 就被释放
4. 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。
5. Push Cache 中的缓存只能被使用一次
6. 浏览器可以拒绝接受已经存在的资源推送
7. 可以给其他域名推送资源

## 微前端

一种类似于 微服务的架构，它将微服务的理念应用于 浏览器端，将 Web应用由单一的应用转变为多个小型前端应用聚合为一的应用

各个前端应用 可以 使用 不同技术栈、 独立运行、独立开发、独立部署

不是框架或工具，而是一套 架构体系

**解决问题**

1. 将庞大应用拆分，每个部分可以单独部署 、维护，提升效率
2. 整合系统，在基本不修改原来系统逻辑的同时 兼容新老老套系统并行运行

**技术方案**

思想就是拆解和整合应用，通常是一个父应用加上一些子应用

* Nginx路由转发

实现不同路径映射到不同应用，这不属于是前端层面的改造，更多是运维的配置

简单、快速、易配置，切换应用时触发浏览器刷新会引用体验

* iframe嵌套

子应用嵌套iframe，父子通信可采用POSTMessage或contentWindow实现

实现简单、子应用间自带沙箱隔离 互不影响、iframe样式显示有兼容性、太过简单显得low

* Web Components

子应用采用 纯 Web Components技术编写，是全新的开发模式

可单独部署，系统改造成本高，子应用通信复杂 易 踩坑

* 组合式 应用路由分发

子应用独立构建和部署，父应用管理路由、应用加载、启动、卸载和通信

纯前端改造、体验好、可无感切换，需设计和开发父子应用于同一页面运行，需解决子应用样式冲突、变量对象污染、通信等技术点

**应用隔离**

分为 主应用 和 微应用

微应用间的JS执行环境隔离、CSS隔离

> CSS隔离

主微应用 同屏渲染时，可能有样式会相互污染，需要彻底隔离CSS污染，可采用CSS module或命名空间的方式，保证不相互干扰，或者webpack的postcss插件，打包时加上特定的前缀

微应用 间的CSS隔离，应用加载时，将应用所有的link和style进行标记，卸载应用时再同步卸载即可

> JS隔离

使用沙箱机制，避免对全局window和全局事件的修改

浏览器可结合with关键字或Proxy实现浏览器端沙箱

保证局部JS运行时，对对外部对象的访问和修改在可控范围内
