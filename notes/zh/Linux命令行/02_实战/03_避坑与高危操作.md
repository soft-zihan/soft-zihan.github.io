# ⚠️ 高危操作与防坑指南

Linux 赋予了用户极高的权限，但也意味着误操作的代价巨大。以下是新手必须知道的“保命”法则。

## 1. 权限重定向陷阱 (sudo vs >)
这是一个经典坑：你想给一个受保护的文件追加一行内容。
- ❌ `sudo echo "127.0.0.1 mylocal" >> /etc/hosts`
- **为什么失败**：`sudo` 只作用于 `echo`，而 `>>` 重定向是由当前 **Shell** 处理的。你的 Shell 没有写入 `/etc/hosts` 的权限。
- ✅ **正确姿势 (`tee`)**：
  `echo "127.0.0.1 mylocal" | sudo tee -a /etc/hosts > /dev/null`
  - `tee` 命令会读取标准输入并写入文件，配合 `sudo` 就能以 root 身份写入。

---

## 2. 环境变量修改规范
配置环境变量（如 Java, Go, Path）是新手的日常。
- **原则**：**不要**直接修改 `/etc/profile` 或 `/etc/environment`。
- **推荐做法**：
  1.  修改当前用户的 `~/.bashrc` 或 `~/.zshrc`。
  2.  **先备份**：`cp ~/.bashrc ~/.bashrc.bak`。
  3.  **生效**：修改后执行 `source ~/.bashrc` 立即生效，而不需要重启终端。
- **避坑**：如果 `source` 之后命令全失效了，说明你的 `PATH` 写错了。赶紧用 `/usr/bin/cp ~/.bashrc.bak ~/.bashrc` 还原。

---

## 3. 远程操作“断线”预案
在修改远程服务器的 SSH 端口、防火墙（ufw/iptables）或网卡配置时：
- **致命后果**：配置错误导致你被挡在服务器外，只能跑机房。
- **防坑方案**：
  - **使用 `at` 命令定时还原**：执行危险操作前，设置一个 5 分钟后的自动任务将配置改回来。如果 5 分钟后你还能连上，再取消任务。
  - **永远在 `tmux` 中操作**：即使网络断开，你的进程（如正在执行的编译或备份）也不会中断。

---

## 4. 删除需谨慎 (rm)
- **致命空格**：
  - ❌ `rm -rf / usr/lib`：注意 `/` 后面的空格！这会尝试删除根目录。
  - ❌ **`rm -rf /*`**：这会尝试删除根目录下的所有内容。永远不要在好奇心的驱使下在任何非虚拟机环境尝试。
  - ✅ **养成习惯**：永远不要手动输入包含 `rm -rf` 的长路径，尽量使用 **Tab 键补全**。或者先用 `ls` 确认路径，再把 `ls` 替换成 `rm`。

---

## 5. 保护你的秘密 (Shell History)
- **不要在命令里打密码**：
  - ❌ `mysql -u root -p123456`
  - **风险**：你的密码会被明文记录在 `~/.bash_history` 中。任何能接触你电脑的人只需输入 `history` 就能看到。
  - ✅ **正确姿势**：使用 `-p` 但不跟密码，让程序提示你输入，此时输入是不可见的。
- **临时忽略历史**：在命令前加一个**空格** (取决于 Shell 配置)，该条命令通常不会被记录到历史中。

---

## 6. 磁盘操作“核武器” (dd)
`dd` 用于底层的位拷贝，常用于制作启动盘或备份硬盘。
- **高危操作**：`sudo dd if=ubuntu.iso of=/dev/sdb`
- **警告**：`of` (Output File) 如果选错了磁盘（比如选成了你的系统盘 `/dev/sda`），它会**不经过任何确认**直接覆盖整个磁盘。
- **安全建议**：执行前执行 `lsblk` 三次确认目标磁盘名称。

---

## 7. Shell 级安全习惯
- **防止 > 误覆盖文件**：
  - 在 `.bashrc` 中加入 `set -o noclobber`。
  - **效果**：当你执行 `echo "test" > existing_file` 时，Shell 会报错提醒文件已存在。如果你确定要覆盖，使用 `>|` 即可。
- **脚本开头必写**：
  - `set -euo pipefail` (脚本的“防弹衣”)：
    - **`-e` (Exit)**：脚本只要有一个命令执行失败，就立即退出。防止错误雪崩。
    - **`-u` (Unset)**：如果脚本尝试引用一个没定义的变量，立即报错退出。
      - **🚨 恐怖案例**：
        假设你写了 `rm -rf $TMP_DIR/`。如果因为某种原因 `$TMP_DIR` 没被赋值，该命令就会变成 **`rm -rf /`**。有了 `-u`，脚本会在此时直接报错崩溃，从而保住你的系统。
    - **`-o pipefail`**：管道中只要有一个子命令失败，整个管道就返回失败。默认情况下，管道只看最后一个命令的结果。

