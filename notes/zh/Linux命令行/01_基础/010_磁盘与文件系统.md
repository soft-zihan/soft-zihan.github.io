# 💽 磁盘与文件系统 (Disk & Filesystem)

前面在文件管理中已经零散提到过 `du` / `df`、Inode 等概念。本章把与**磁盘空间 / 分区 / 文件系统**相关的常用命令系统性整理出来，方便在“磁盘报警”“磁盘满了”时快速定位问题。

---

## 1. 核心概念速览

- **磁盘 (Disk)**：物理设备，比如 `/dev/sda`、`/dev/nvme0n1`。
- **分区 (Partition)**：对磁盘进行逻辑划分，比如 `/dev/sda1`。
- **文件系统 (Filesystem)**：在分区上建立的组织结构，如 `ext4`、`xfs`、`btrfs`。
- **挂载点 (Mount point)**：把文件系统“挂”到目录树中的某个目录，比如 `/`、`/home`、`/data`。

> 记忆方式：**磁盘 → 分区 → 文件系统 → 挂载点**，像是“硬盘 → 划区域 → 格一下 → 挂到某个目录”。

---

## 2. 查看磁盘与分区结构

### 2.1 lsblk：用树状图看磁盘

```bash
lsblk
lsblk -f   # 带上文件系统类型和挂载点
```

- 常见列说明：
  - `NAME`：设备名称，如 `sda`、`sda1`。
  - `TYPE`：`disk` (磁盘)、`part` (分区)、`lvm` (逻辑卷) 等。
  - `FSTYPE`：文件系统类型，比如 `ext4`、`xfs`。
  - `MOUNTPOINT`：分区挂载到的目录。

### 2.2 fdisk / parted：更底层的分区视图

只读查看即可，**不要在生产环境随意修改分区表**。

```bash
sudo fdisk -l
```

用于详细列出每块磁盘的分区起止位置、类型等。

---

## 3. df 与 du：空间到底去哪了？

### 3.1 df：看“每个挂载点”用了多少

```bash
df -h          # 按分区查看磁盘空间使用情况
df -hT         # 额外显示文件系统类型
df -i          # 查看 inode 使用情况
```

- 常见列说明：
  - `Filesystem`：设备或挂载点来源。
  - `Size`：总容量。
  - `Used` / `Avail`：已用 / 可用空间。
  - `Use%`：使用百分比。
  - `Mounted on`：挂载到哪个目录，例如 `/`、`/home`、`/var`。

> 💡 遇到“磁盘满了”的报警，一般**第一步就是 `df -h`**，看是哪个分区爆满。

### 3.2 du：查“哪个目录/文件”占得最多

```bash
du -sh /var/log
du -sh *       # 当前目录下各子目录/文件的占用情况
du -ah . | sort -rh | head -n 20
```

- 选项说明：
  - `-s`：summary，只给每个参数一行汇总。
  - `-h`：人类可读。
  - `-a`：包含文件，否则默认只统计目录。

> 常用组合：**先 `df -h` 找到爆满的分区挂载点，再 `cd` 到挂载点里用 `du -sh *` 一层层往下钻**。

---

## 4. 挂载与卸载：mount / umount

### 4.1 临时挂载一个分区

```bash
sudo mkdir -p /data
sudo mount /dev/sdb1 /data
```

- 临时挂载 **只在当前启动周期有效**，系统重启后会失效。
- 使用 `df -h` 或 `lsblk` 确认是否挂载成功。

### 4.2 卸载分区

```bash
sudo umount /data
```

> 如果提示“target is busy”，说明还有进程在使用这个挂载点，可以：
>
> - 用 `lsof +D /data` 查看具体进程；
> - 确认没有人在该目录下 `cd` 着；
> - 结束相关进程或切换目录后再卸载。

### 4.3 使用 findmnt 查看挂载关系

```bash
findmnt
findmnt /data
```

比手写 `mount | grep` 更直观。

---

## 5. /etc/fstab：开机自动挂载

如果你有一块数据盘希望**每次开机都自动挂到 `/data`**，需要编辑 `/etc/fstab`。

### 5.1 获取分区的 UUID

```bash
blkid /dev/sdb1
```

输出类似：

```text
/dev/sdb1: UUID="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" TYPE="ext4"
```

### 5.2 编辑 /etc/fstab

在文件末尾加一行（示例）：

```text
UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx  /data  ext4  defaults  0  2
```

- 字段含义：
  - 设备：推荐用 `UUID=` 而不是 `/dev/sdb1`（避免设备名变化）。
  - 挂载点：`/data`
  - 文件系统类型：`ext4`
  - 挂载选项：常用 `defaults`

### 5.3 安全测试

`/etc/fstab` 写错会导致系统启动失败，务必先测试：

```bash
sudo mount -a
```

如果没有报错，说明配置语法基本是正确的。

---

## 6. Inode：空间没满，为什么还写不进文件？

有时你会遇到这样的情况：

- `df -h` 显示还有很多剩余空间；
- 但写文件时报错：`No space left on device`。

这通常是 **inode 用完了**。

### 6.1 inode 是什么？

- 可以理解为“文件的编号槽位”，每个文件/目录都要占用一个 inode。
- inode 用完后，即使磁盘空间还有富余，也不能再新建文件。

### 6.2 如何判断 inode 是否耗尽？

```bash
df -i
```

关注 `IUse%` 列，当接近 100% 时说明 inode 紧张。

### 6.3 如何排查是谁占满了 inode？

典型场景是某个目录下疯狂生成了**大量小文件**：

```bash
sudo find / -xdev -type d -print0 | \
  xargs -0 -n 1 -I{} sh -c 'echo -n "{}: "; find "{}" -maxdepth 1 -type f | wc -l' | \
  sort -k2 -nr | head
```

> 解释：对每个目录统计其中的文件数量，按从多到少排序，快速找出“文件海洋”。

找到问题目录后，再决定是否清理或压缩。

---

## 7. LVM / RAID：只做概念级认识

> 如果你是刚入门运维，可以先把这一节当做“见过就行”，真正用到时再展开查资料。

- **LVM (Logical Volume Manager)**：在物理磁盘之上再加一层抽象，允许你**动态扩容 / 缩容**逻辑卷。
  - 常见命令：`pvs`、`vgs`、`lvs`
- **RAID**：用多块磁盘组合出一个逻辑磁盘，提高性能或可靠性。
  - RAID1：镜像，写两份，读可分摊
  - RAID5/6：带奇偶校验，有一定容错能力

排障时要注意：

- 不要只看最上层的挂载点，必要时用 `lsblk` 看看下面是不是 LVM/RAID。
- 在云环境中，很多盘其实是“云厂商管理的虚拟盘”，底层 RAID/LVM 等常已托管，无需自己配置。

---

## 8. 常见磁盘故障排查路径

### 8.1 磁盘快满/已满

1. `df -h`：找出 **Use% 接近或等于 100% 的分区**。
2. `cd` 到对应挂载点，比如 `/var`。
3. 用 `du` 逐层下钻：

```bash
sudo du -sh * | sort -rh | head
```

4. 找到最大几个目录后，视情况：
   - 日志目录 → 结合“日志与排错实战”一章，配合 logrotate 处理；
   - 临时文件 → 确认无用后清理；
   - 数据目录 → 考虑归档、迁移或扩容。

### 8.2 inode 用完

1. `df -i`：找出 `IUse%` 接近 100% 的分区。
2. 在对应挂载点下，用上一节的“统计文件数量”命令找出文件过多的目录。
3. 排查是否存在：
   - 程序 bug：频繁生成小临时文件但不删除；
   - 日志切割策略不当：大量小日志文件散落各处。

### 8.3 文件系统只读 (read-only)

有时某个分区突然变成只读，写入时报错：`Read-only file system`。

常见原因：

- 文件系统检测到严重错误，为保护数据自动切到只读模式；
- 人为用只读选项挂载。

排查步骤示例：

```bash
dmesg | tail -n 50
mount | grep /data
```

如果确认是文件系统错误，需要：

- 在维护窗口卸载分区；
- 用 `fsck` 对该分区进行检查与修复；
- 或（云厂商环境）按照其文档流程操作。

---

掌握本章内容后，再遇到“磁盘报警”类问题，你就可以做到：
**先判断是哪个分区出了问题 → 再锁定是空间还是 inode → 最后精确定位到具体目录/文件**。
