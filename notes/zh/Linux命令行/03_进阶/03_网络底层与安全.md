# 🛡️ 网络底层与安全实战

> **常见真实场景**：
> “知道三次握手还不够：抓过包吗？TIME_WAIT 多了会怎样？如何在不重启服务的情况下观测系统和网络（eBPF）？”

本章节将带你从“背诵八股文”进阶到“看穿网络流量”。

## 1. TCP/IP 协议栈实战

### 1.1 三次握手与四次挥手 (Tcpdump 视角)
别只看图，我们要用 `tcpdump` 亲眼看到。

**抓包命令**：
`sudo tcpdump -i eth0 port 80 -nn -S -tttt` (不做 DNS/端口解析 + 显示绝对序列号 + 打印完整时间)

常用参数速记：
* `-nn`：不做 DNS 反查/端口名解析（抓包时建议默认开，避免误判与卡顿）
* `-S`：显示绝对序列号（对照握手/重传更直观）
* `-tttt`：打印带日期的时间戳（方便跟日志对齐）

**场景复现**：你在另一终端 `curl http://1.2.3.4`

**握手 (Connection Establishment)**:
1.  **SYN**: `Client -> Server` (Flags [S], seq 100) -> 我想连你。
2.  **SYN+ACK**: `Server -> Client` (Flags [S.], seq 200, ack 101) -> 好的，我也想连你。
3.  **ACK**: `Client -> Server` (Flags [.], ack 201) -> 知道了，连接建立。

**挥手 (Connection Termination)**:
1.  **FIN**: `Client -> Server` (Flags [F.], seq 101) -> 我话说完了，挂了。
2.  **ACK**: `Server -> Client` (Flags [.], ack 102) -> 知道了 (此时 Server 还能发数据)。
3.  **FIN**: `Server -> Client` (Flags [F.], seq 201) -> 我也说完了，挂了。
4.  **ACK**: `Client -> Server` (Flags [.], ack 202) -> 好的，再见。

### 1.2 经典面试题：TIME_WAIT vs CLOSE_WAIT

*   **TIME_WAIT**:
    *   **谁产生**：**主动断开连接的一方** (通常是 Client，但在反向代理中 Nginx 是 Client)。
    *   **现象**：`ss -ant state time-wait | head` 看到很多条。
    *   **原因**：主动关闭方发完最后一个 ACK 后，需要等待 2MSL 时间，确保 Server 收到了 ACK。如果 Server 没收到会重发 FIN，Client 需要在 TIME_WAIT 状态下再次发送 ACK。
    *   **危害**：在“需要大量主动外连”的角色上会消耗本地临时端口（比如反向代理连上游、服务端大量短连接访问数据库/Redis/HTTP 上游）。端口耗尽时，新连接会失败。
    *   **优先优化（更安全）**：
        1. 应用层：连接复用/连接池/keepalive，减少短连接（比任何 sysctl 都更优先）。
        2. 端口资源：确认临时端口范围是否过窄：`cat /proc/sys/net/ipv4/ip_local_port_range`。
        3. 观测：看 socket 汇总与状态分布：`ss -s`、`ss -ant | awk '{print $1}' | sort | uniq -c | sort -rn | head`。
    *   **谨慎项**：`tcp_tw_reuse` 很容易被“抄答案”误用。它主要影响主动发起连接一侧的复用行为，并不适合无脑开启；在不同内核版本/网络环境（特别是 NAT/负载均衡路径复杂）下可能带来难以解释的连接异常。把它当作“最后手段”，并在开启前先把连接复用与端口范围做对。
*   **CLOSE_WAIT**:
    *   **谁产生**：**被动关闭的一方** (Server)。
    *   **现象**：Server 收到了 FIN，回了 ACK，但**没有发送自己的 FIN**。
    *   **原因**：**代码 Bug**。程序逻辑卡住了，没有调用 `close()` 关闭 socket。
    *   **结论**：发现大量 CLOSE_WAIT，直接找开发改代码，不是系统配置问题。

一个能迅速定位 “TIME_WAIT 是谁产生的” 的命令：

```bash
ss -ant state time-wait '( sport = :80 or dport = :80 )' | head
```

---

## 2. Linux 防火墙：Iptables

虽然有了 `ufw` 和 `firewalld`，但底层依然是 `iptables` (或 nftables)。理解它对理解 Kubernetes 网络至关重要。

### 2.1 四表五链
核心关注 **Filter 表** (过滤) 和 **INPUT 链** (入站)。

### 2.2 常用操作
**查看规则**：`sudo iptables -L -n --line-numbers`

更“可复制”的查看方式（便于粘贴到文档/评审）：`sudo iptables -S`

很多发行版当前是 nftables 后端（iptables 命令只是前端），遇到“命令能跑但结果看不懂/不一致”，优先确认系统实际使用的是 iptables-legacy 还是 iptables-nft。

**封锁攻击 IP**：
```bash
sudo iptables -I INPUT -s 192.168.1.100 -j DROP
```
*   `-I INPUT`: 插入到 INPUT 链最前面。
*   `-s`: 来源 IP。
*   `-j DROP`: 动作是丢弃 (对方会超时)，`REJECT` 是拒绝 (对方会收到拒绝包)。

**开放端口**：
```bash
sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
```

**删除规则**：
`sudo iptables -D INPUT 1` (删除 INPUT 链第 1 条规则)

---

## 3. 下一代黑科技：eBPF (加分项)

如果面试官问你：“如何在不重新编译内核、不重启服务的情况下，监控所有进程打开了哪些文件？”
答案是：**eBPF (Extended Berkeley Packet Filter)**。

### 3.1 什么是 eBPF？
它是 Linux 内核中的一个**虚拟机**。
*   你可以写一段代码，通过校验后，**安全地注入到内核**中运行。
*   **用途**：高性能网络包处理 (Cilium)、系统观测 (BCC)、安全监控 (Falco)。

### 3.2 BCC 工具集 (实战)
不需要你会写 eBPF C 代码，只需会用 BCC 工具箱。

**安装**：`sudo apt install bpfcc-tools`

两个现实前提：
* 绝大多数 BCC 工具需要 root 权限（或特定 capability），并且对内核能力有要求。
* 不同发行版的包名/工具名后缀会不一样（例如 Debian 系常见 `*-bpfcc`）。

**神级工具演示**：
1.  **`execsnoop`**: 实时监控全系统**谁在运行什么命令**。
    *   *场景*：有人偷偷在服务器上挖矿，但他改了 `ps` 命令让你看不到。用 `execsnoop` 直接监控内核系统调用，他无处遁形。
    *   `sudo execsnoop-bpfcc`
2.  **`opensnoop`**: 监控谁在**打开什么文件**。
    *   *场景*：Nginx 启动报错“配置文件找不到”，但没说是哪个文件。用 `opensnoop` 一看便知。
3.  **`tcptop`**: 实时显示 TCP 连接流量排行（内核级统计，比 `ss`/`netstat` 更轻量）。

如果你不想依赖 BCC，另两条常见路线是：
* `bpftrace`：一条命令写脚本，适合临时观测
* `bpftool` / `libbpf-tools`：更偏“原生 eBPF”工具链（偏系统级）

> **总结**：在校招中提到 eBPF 和 BCC 工具，会给面试官留下“技术视野开阔、关注前沿技术”的极佳印象。
