<!--
author: 热心网友
authorUrl: https://github.com/small-hamburger
-->

## 基础

[](https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md#%E5%9F%BA%E7%A1%80)

### 前言：为什么要学习 Bash？

市面上有很多现代化的 Shell（如 zsh, fish），它们拥有炫酷的自动补全和漂亮的主题。但是，**Bash (Bourne Again SHell)** 是几乎所有 Linux 发行版和 Unix 系统的默认标准。

- **通用性**：无论你登录到哪台远程服务器、Docker 容器或嵌入式设备，Bash 几乎总是存在的。
    
- **稳定性**：如果你过度依赖 zsh/fish 的插件，一旦进入只有 Bash 的生产环境，你会感到手足无措。
    

> **任务 0**：打开你的终端，输入 man bash。虽然文档很长，但请尝试浏览一遍。你不需要背诵，只需要知道 Bash 的能力边界在哪里。

---

### 第一章：学会“自救”——阅读文档

在 Linux 世界里，最好的老师是系统自带的文档。

#### 1.1 使用 man (Manual)

- **基础**：输入 man <命令> 查看手册。
    
    - 按 空格 翻页，按 q 退出。
        
    - 按 / 输入关键字进行搜索（如 /pattern），按 n 跳转下一个匹配项。
        
- **查找命令**：如果你不知道命令的具体名称，只知道大概用途，使用 apropos。
    
    - 例如：apropos "list directory" 会告诉你 ls 是你需要的命令。
        

#### 1.2 内置命令 vs 可执行文件

并不是所有命令都是独立的文件（可执行文件），有些命令是直接写在 Bash 内部的（Built-ins）。

- **判断类型**：使用 type <命令>。
    
    - type cd -> cd is a shell builtin
        
    - type grep -> grep is /usr/bin/grep
        
- **获取内置命令帮助**：man 并不总是适用于内置命令。
    
    - 使用 help <命令>，例如 help cd。
        
    - 简略模式：help -d <命令>。
        

---

### 第二章：掌控数据流——重定向与管道

Linux 的哲学是“一切皆文件”，数据流也是如此。

#### 2.1 标准流 (Standard Streams)

- **stdin (0)**：标准输入（通常是键盘）。
    
- **stdout (1)**：标准输出（通常是屏幕）。
    
- **stderr (2)**：标准错误（错误信息的输出，通常也是屏幕）。
    

#### 2.2 重定向操作符

- **覆盖输出 (>)**：将命令结果写入文件，如果文件存在则**覆盖**。
    
    - echo "Hello" > file.txt
        
- **追加输出 (>>)**：将命令结果写入文件，如果文件存在则**追加**到末尾。
    
    - echo "World" >> file.txt
        
- **输入重定向 (<)**：让命令从文件获取输入而不是键盘。
    
    - python script.py < input_data.txt
        

#### 2.3 管道 (|)

这是命令行最强大的功能。它将**前一个命令的 stdout** 直接连接到**后一个命令的 stdin**。

- 例子：ls -l | grep ".txt" （列出文件，然后从中筛选出 txt 文件）。
    

---

### 第三章：Shell 的语言艺术——通配符与引用

#### 3.1 通配符 (Globbing)

当你不想逐个输入文件名时，使用通配符匹配：

- *****：匹配任意长度的字符（包括空字符）。
    
    - rm *.jpg （删除所有 jpg 文件）。
        
- **?**：匹配任意**单个**字符。
    
    - ls file?.txt （匹配 file1.txt, fileA.txt，但不匹配 file10.txt）。
        
- **[...]**：匹配括号内的任意一个字符。
    
    - ls [abc]* （列出所有以 a, b 或 c 开头的文件）。
        

#### 3.2 引用：单引号 vs 双引号

这是新手最容易混淆的地方：

- **单引号 (' ')**：**强引用**。引号内的所有内容都被视为字面量，特殊字符（如 $）失效。
    
    - echo '$HOME' -> 输出 $HOME (原样输出)。
        
- **双引号 (" ")**：**弱引用**。保留大部分字符的字面值，但允许**变量扩展**。
    
    - echo "$HOME" -> 输出 /home/yourname (变量被解析了)。
        

---

### 第四章：多任务处理——任务管理

你不需要开启多个终端窗口来运行多个任务。

#### 4.1 核心操作

- **后台运行 (&)**：在命令末尾加上 &，命令会直接在后台运行。
    
    - python server.py &
        
- **挂起任务 (Ctrl-Z)**：将当前正在前台运行的任务暂停并放入后台。
    
- **终止任务 (Ctrl-C)**：强制停止当前前台任务。
    

#### 4.2 管理后台任务

- **jobs**：查看当前 Shell 下所有的后台/挂起任务。
    
- **fg (Foreground)**：将后台任务调回前台（继续操作）。
    
    - fg %1 （调回任务号为 1 的任务）。
        
- **bg (Background)**：让挂起的任务在后台继续运行。
    
- **kill**：杀掉进程。
    
    - kill %1 （杀掉任务号 1）。
        
    - kill <PID> （根据进程 ID 杀掉进程）。
        

---

### 第五章：远程连接——SSH

- **基本登录**：ssh username@host_ip
    
- **免密登录 (Key-based Auth)**：
    
    1. 本地生成密钥：ssh-keygen -t ed25519
        
    2. 上传公钥到服务器：ssh-copy-id username@host_ip
        
- **SSH Agent**：如果你的密钥设置了密码，不想每次都输入：
    
    - 启动 agent：eval "$(ssh-agent -s)"
        
    - 添加密钥：ssh-add ~/.ssh/id_ed25519
        

---

### 第六章：文件与系统管理 (瑞士军刀)

#### 6.1 文件查看与操作

- **ls -l 解析**：
    
    - 输出如：drwxr-xr-x 2 user group 4096 Dec 26 10:00 folder
        
    - 第一列：权限（d代表目录，rwx代表读写执行）。第三/四列：所有者/所属组。
        
- **查看内容**：
    
    - less filename：支持上下滚动的查看器（按 q 退出）。
        
    - head -n 5 file：看前5行。
        
    - tail -n 5 file：看后5行。
        
    - **tail -f file**：实时监控文件追加的内容（常用于看日志）。
        
        - 技巧：在 less 中按 Shift+F 可以进入类似 tail -f 的模式，按 Ctrl-C 返回普通模式。
            
- **链接**：
    
    - ln -s target linkname：**软链接**（类似 Windows 快捷方式，原文件删了链接失效）。
        
    - ln target linkname：**硬链接**（指向同一个 inode，删了原文件，硬链接内容还在）。
        
- **权限与归属**：
    
    - chmod +x script.sh （添加执行权限），chmod 755 folder。
        
    - chown user:group file （修改文件所有者）。
        

#### 6.2 磁盘与文件系统

- **磁盘空间**：
    
    - du -hs *：以人类可读格式（Human-readable, -h）汇总（Summary, -s）当前目录下每个文件/文件夹的大小。非常实用！
        
    - df -h：查看整个磁盘分区的挂载点和剩余空间。
        
- **高级管理**：
    
    - lsblk：列出所有块设备（硬盘、分区）。
        
    - mount /dev/sdb1 /mnt/usb：挂载硬盘。
        
    - inode：文件系统的索引节点。如果磁盘空间未满但无法创建文件，可能是 inode 耗尽。
        
        - 检查命令：df -i。
            

---

### 第七章：网络工具

- **IP 地址**：
    
    - 新标准：ip addr (或 ip a)。
        
    - 旧标准：ifconfig (可能需要安装 net-tools)。
        
- **DNS 查询**：
    
    - dig google.com：查询域名的 DNS 解析记录。
        


---

## 第八章：进阶文本处理Grep

grep 用于在文本中查找匹配的行，支持**正则表达式**。

- 基础用法：grep "error" log.txt
    
- **必学参数**：
    
    - **-i**：忽略大小写。
        
    - **-v**：反选（显示**不**包含匹配内容的行）。
        
    - **-o**：只输出匹配到的部分，而不是整行。
        
    - **上下文控制**（调试神器）：
        
        - -A 5 (After)：显示匹配行及之后5行。
            
        - -B 5 (Before)：显示匹配行及之前5行。
            
        - -C 5 (Context)：显示前后各5行。
    

## 日常使用

[](https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md#%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8)

- 在 Bash 中，可以通过按 **Tab** 键实现自动补全参数，使用 **ctrl-r** 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 **ctrl-r** 会向后查找匹配项，按下 **Enter** 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。
    
- 在 Bash 中，可以按下 **ctrl-w** 删除你键入的最后一个单词，**ctrl-u** 可以删除行内光标所在位置之前的内容，**alt-b** 和 **alt-f** 可以以单词为单位移动光标，**ctrl-a** 可以将光标移至行首，**ctrl-e** 可以将光标移至行尾，**ctrl-k** 可以删除光标至行尾的所有内容，**ctrl-l** 可以清屏。键入 `man readline` 可以查看 Bash 中的默认快捷键。内容有很多，例如 **alt-.** 循环地移向前一个参数，而 **alt-*** 可以展开通配符。
    
- 你喜欢的话，可以执行 `set -o vi` 来使用 vi 风格的快捷键，而执行 `set -o emacs` 可以把它改回来。
    
- 为了便于编辑长命令，在设置你的默认编辑器后（例如 `export EDITOR=vim`），**ctrl-x** **ctrl-e** 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 **escape-v**。
    
- 键入 `history` 查看命令行历史记录，再用 `!n`（`n` 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 `!$`， 它用于指代上次键入的参数，而 `!!` 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 **ctrl-r** 和 **alt-.** 来实现。
    
- `cd` 命令可以切换工作路径，输入 `cd ~` 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 `~`（例如 `~/.bashrc`）。在 `sh` 脚本里则用环境变量 `$HOME` 指代 home 目录的路径。
    
- 回到前一个工作路径：`cd -`。
    
- 如果你输入命令的时候中途改了主意，按下 **alt-#** 在行首添加 `#` 把它当做注释再按下回车执行（或者依次按下 **ctrl-a**， **#**， **enter**）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。
    
- 使用 `xargs` （ 或 `parallel`）。他们非常给力。注意到你可以控制每行参数个数（`-L`）和最大并行数（`-P`）。如果你不确定它们是否会按你想的那样工作，先使用 `xargs echo` 查看一下。此外，使用 `-I{}` 会很方便。例如：
    

```shell
      find . -name '*.py' | xargs grep some_function
      cat hosts | xargs -I{} ssh root@{} hostname
```

- `pstree -p` 以一种优雅的方式展示进程树。
    
- 使用 `pgrep` 和 `pkill` 根据名字查找进程或发送信号（`-f` 参数通常有用）。
    
- 了解你可以发往进程的信号的种类。比如，使用 `kill -STOP [pid]` 停止一个进程。使用 `man 7 signal` 查看详细列表。
    
- 使用 `nohup` 或 `disown` 使一个后台进程持续运行。
    
- 使用 `netstat -lntp` 或 `ss -plat` 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 `-u` 则检查 UDP 端口）或者 `lsof -iTCP -sTCP:LISTEN -P -n` (这也可以在 OS X 上运行)。
    
- `lsof` 来查看开启的套接字和文件。
    
- 使用 `uptime` 或 `w` 来查看系统已经运行多长时间。
    
- 使用 `alias` 来创建常用命令的快捷形式。例如：`alias ll='ls -latr'` 创建了一个新的命令别名 `ll`。
    
- 可以把别名、shell 选项和常用函数保存在 `~/.bashrc`，具体看下这篇[文章](http://superuser.com/a/183980/7106)。这样做的话你就可以在所有 shell 会话中使用你的设定。
    
- 把环境变量的设定以及登陆时要执行的命令保存在 `~/.bash_profile`。而对于从图形界面启动的 shell 和 `cron` 启动的 shell，则需要单独配置文件。
    
- 要想在几台电脑中同步你的配置文件（例如 `.bashrc` 和 `.bash_profile`），可以借助 Git。
    
- 当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 `"$FOO"`。尽量使用 `-0` 或 `-print0` 选项以便用 NULL 来分隔文件名，例如 `locate -0 pattern | xargs -0 ls -al` 或 `find / -print0 -type d | xargs -0 ls -al`。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 `IFS=$'\n'` 把内部字段分隔符设为换行符。
    
- 在 Bash 脚本中，使用 `set -x` 去调试输出（或者使用它的变体 `set -v`，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 `set -e` 令脚本在发生错误时退出而不是继续运行；使用 `set -u` 来检查是否使用了未赋值的变量；试试 `set -o pipefail`，它可以监测管道中的错误。当牵扯到很多脚本时，使用 `trap` 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息：
    

```shell
      set -euo pipefail
      trap "echo 'error: Script failed: see failed command above'" ERR
```

- 在 Bash 脚本中，子 shell（使用括号 `(...)`）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：

```shell
      # do something in current dir
      (cd /some/other/dir && other-command)
      # continue in original dir
```

- 在 Bash 中，变量有许多的扩展方式。`${name:?error message}` 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 `input_file=${1:?usage: $0 input_file}`。在变量为空时使用默认值：`${name:-default}`。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 `output_file=${2:-logfile}`，如果省略了 $2，它的值就为空，于是 `output_file` 就会被设为 `logfile`。数学表达式：`i=$(( (i + 1) % 5 ))`。序列：`{1..10}`。截断字符串：`${var%suffix}` 和 `${var#prefix}`。例如，假设 `var=foo.pdf`，那么 `echo ${var%.pdf}.txt` 将输出 `foo.txt`。
    
- 使用括号扩展（`{`...`}`）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 `mv foo.{txt,pdf} some-dir`（同时移动两个文件），`cp somefile{,.bak}`（会被扩展成 `cp somefile somefile.bak`）或者 `mkdir -p test-{a,b,c}/subtest-{1,2,3}`（会被扩展成所有可能的组合，并创建一个目录树）。
    
- 通过使用 `<(some command)` 可以将输出视为文件。例如，对比本地文件 `/etc/hosts` 和一个远程文件：
    

```shell
      diff /etc/hosts <(ssh somehost cat /etc/hosts)
```

- 编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。

```shell
{
      # 在这里写代码
}
```

- 了解 Bash 中的“here documents”，例如 `cat <<EOF ...`。
    
- 在 Bash 中，同时重定向标准输出和标准错误：`some-command >logfile 2>&1` 或者 `some-command &>logfile`。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 `</dev/null` 是一个好习惯。
    
- 使用 `man ascii` 查看具有十六进制和十进制值的ASCII表。`man unicode`，`man utf-8`，以及 `man latin1` 有助于你去了解通用的编码信息。
    
- 使用 `screen` 或 [`tmux`](https://tmux.github.io/) 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 `byobu` 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 [`dtach`](https://github.com/bogner/dtach)。
    
- ssh 中，了解如何使用 `-L` 或 `-D`（偶尔需要用 `-R`）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。
    
- 对 ssh 设置做一些小优化可能是很有用的，例如这个 `~/.ssh/config` 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项：
    

```
      TCPKeepAlive=yes
      ServerAliveInterval=15
      ServerAliveCountMax=6
      Compression=yes
      ControlMaster auto
      ControlPath /tmp/%r@%h:%p
      ControlPersist yes
```

- 一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 `StrictHostKeyChecking=no`，`ForwardAgent=yes`。
    
- 考虑使用 [`mosh`](https://mosh.org/) 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。
    
- 获取八进制形式的文件访问权限（修改系统设置时通常需要，但 `ls` 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码：
    

```shell
      stat -c '%A %a %n' /etc/timezone
```

- 使用 [`percol`](https://github.com/mooz/percol) 或者 [`fzf`](https://github.com/junegunn/fzf) 可以交互式地从另一个命令输出中选取值。
    
- 使用 `fpp`（[PathPicker](https://github.com/facebook/PathPicker)）可以与基于另一个命令(例如 `git`）输出的文件交互。
    
- 将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用： `python -m SimpleHTTPServer 7777` （使用端口 7777 和 Python 2）或`python -m http.server 7777` （使用端口 7777 和 Python 3）。
    
- 以其他用户的身份执行命令，使用 `sudo`。默认以 root 用户的身份执行；使用 `-u` 来指定其他用户。使用 `-i` 来以该用户登录（需要输入_你自己的_密码）。
    
- 将 shell 切换为其他用户，使用 `su username` 或者 `su - username`。加入 `-` 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入_哪个用户的_密码。
    
- 了解命令行的 [128K 限制](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong)。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 `find` 或 `xargs` 通常可以解决。）
    
- 当你需要一个基本的计算器时，可以使用 `python` 解释器（当然你要用 python 的时候也是这样）。例如：
    

```
>>> 2+3
5
```

## 文件及数据处理

[](https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md#%E6%96%87%E4%BB%B6%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86)

- 在当前目录下通过文件名查找一个文件，使用类似于这样的命令：`find . -iname '*something*'`。在所有路径下通过文件名查找文件，使用 `locate something` （但注意到 `updatedb` 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。
    
- 使用 [`ag`](https://github.com/ggreer/the_silver_searcher) 在源代码或数据文件里检索（`grep -r` 同样可以做到，但相比之下 `ag` 更加先进）。
    
- 将 HTML 转为文本：`lynx -dump -stdin`。
    
- Markdown，HTML，以及所有文档格式之间的转换，试试 [`pandoc`](http://pandoc.org/)。
    
- 当你要处理棘手的 XML 时候，`xmlstarlet` 算是上古时代流传下来的神器。
    
- 使用 [`jq`](http://stedolan.github.io/jq/) 处理 JSON。
    
- 使用 [`shyaml`](https://github.com/0k/shyaml) 处理 YAML。
    
- 要处理 Excel 或 CSV 文件的话，[csvkit](https://github.com/onyxfish/csvkit) 提供了 `in2csv`，`csvcut`，`csvjoin`，`csvgrep` 等方便易用的工具。
    
- 当你要处理 Amazon S3 相关的工作的时候，[`s3cmd`](https://github.com/s3tools/s3cmd) 是一个很方便的工具而 [`s4cmd`](https://github.com/bloomreach/s4cmd) 的效率更高。Amazon 官方提供的 [`aws`](https://github.com/aws/aws-cli) 以及 [`saws`](https://github.com/donnemartin/saws) 是其他 AWS 相关工作的基础，值得学习。
    
- 了解如何使用 `sort` 和 `uniq`，包括 uniq 的 `-u` 参数和 `-d` 参数，具体内容在后文单行脚本节中。另外可以了解一下 `comm`。
    
- 了解如何使用 `cut`，`paste` 和 `join` 来更改文件。很多人都会使用 `cut`，但遗忘了 `join`。
    
- 了解如何运用 `wc` 去计算新行数（`-l`），字符数（`-m`），单词数（`-w`）以及字节数（`-c`）。
    
- 了解如何使用 `tee` 将标准输入复制到文件甚至标准输出，例如 `ls -al | tee file.txt`。
    
- 要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 [`datamash`](https://www.gnu.org/software/datamash/)。
    
- 注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 `LANG` 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降_许多倍_。某些情况下（例如集合运算）你可以放心的使用 `export LC_ALL=C` 来忽略掉国际化并按照字节来判断顺序。
    
- 你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 `TZ=Pacific/Fiji date` 可以获取斐济的时间。
    
- 了解如何使用 `awk` 和 `sed` 来进行简单的数据处理。 参阅 [One-liners](https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md#one-liners) 获取示例。
    
- 替换一个或多个文件中出现的字符串：
    

```shell
      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt
```

- 使用 [`repren`](https://github.com/jlevy/repren) 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 `rename` 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）

```shell
      # 将文件、目录和内容全部重命名 foo -> bar:
      repren --full --preserve-case --from foo --to bar .
      # 还原所有备份文件 whatever.bak -> whatever:
      repren --renames --from '(.*)\.bak' --to '\1' *.bak
      # 用 rename 实现上述功能（若可用）:
      rename 's/\.bak$//' *.bak
```

- 根据 man 页面的描述，`rsync` 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 `rsync` 代替 `scp` 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的[最快方法](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html)之一：

```shell
mkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir
```

- 若要在复制文件时获取当前进度，可使用 `pv`，[`pycp`](https://github.com/dmerejkowsky/pycp)，[`progress`](https://github.com/Xfennec/progress)，`rsync --progress`。若所执行的复制为block块拷贝，可以使用 `dd status=progress`。
    
- 使用 `shuf` 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。
    
- 了解 `sort` 的参数。显示数字时，使用 `-n` 或者 `-h` 来显示更易读的数（例如 `du -h` 的输出）。明白排序时关键字的工作原理（`-t` 和 `-k`）。例如，注意到你需要 `-k1，1` 来仅按第一个域来排序，而 `-k1` 意味着按整行排序。稳定排序（`sort -s`）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 `sort -k1，1 | sort -s -k2，2`。
    
- 如果你想在 Bash 命令行中写 tab 制表符，按下 **ctrl-v** **[Tab]** 或键入 `$'\t'` （后者可能更好，因为你可以复制粘贴它）。
    
- 标准的源代码对比及合并工具是 `diff` 和 `patch`。使用 `diffstat` 查看变更总览数据。注意到 `diff -r` 对整个文件夹有效。使用 `diff -r tree1 tree2 | diffstat` 查看变更的统计数据。`vimdiff` 用于比对并编辑文件。
    
- 对于二进制文件，使用 `hd`，`hexdump` 或者 `xxd` 使其以十六进制显示，使用 `bvi`，`hexedit` 或者 `biew` 来进行二进制编辑。
    
- 同样对于二进制文件，`strings`（包括 `grep` 等工具）可以帮助在二进制文件中查找特定比特。
    
- 制作二进制差分文件（Delta 压缩），使用 `xdelta3`。
    
- 使用 `iconv` 更改文本编码。需要更高级的功能，可以使用 `uconv`，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号：
    

```shell
      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt
```

- 拆分文件可以使用 `split`（按大小拆分）和 `csplit`（按模式拆分）。
    
- 操作日期和时间表达式，可以用 [`dateutils`](http://www.fresse.org/dateutils/) 中的 `dateadd`、`datediff`、`strptime` 等工具。
    
- 使用 `zless`、`zmore`、`zcat` 和 `zgrep` 对压缩过的文件进行操作。
    
- 文件属性可以通过 `chattr` 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：`sudo chattr +i /critical/directory/or/file`
    
- 使用 `getfacl` 和 `setfacl` 以保存和恢复文件权限。例如：
    

```shell
   getfacl -R /some/path > permissions.txt
   setfacl --restore=permissions.txt
```

- 为了高效地创建空文件，请使用 `truncate`（创建[稀疏文件](https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E6%96%87%E4%BB%B6)），`fallocate`（用于 ext4，xfs，btrf 和 ocfs2 文件系统），`xfs_mkfile`（适用于几乎所有的文件系统，包含在 xfsprogs 包中），`mkfile`（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。

## 系统调试

[](https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md#%E7%B3%BB%E7%BB%9F%E8%B0%83%E8%AF%95)

- `curl` 和 `curl -I` 可以被轻松地应用于 web 调试中，它们的好兄弟 `wget` 也是如此，或者也可以试试更潮的 [`httpie`](https://github.com/jkbrzt/httpie)。
    
- 获取 CPU 和硬盘的使用状态，通常使用使用 `top`（`htop` 更佳），`iostat` 和 `iotop`。而 `iostat -mxz 15` 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。
    
- 使用 `netstat` 和 `ss` 查看网络连接的细节。
    
- `dstat` 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 [`glances`](https://github.com/nicolargo/glances)，它会在一个终端窗口中向你提供一些系统级的数据。
    
- 若要了解内存状态，运行并理解 `free` 和 `vmstat` 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。
    
- Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 `kill -3 <pid>` 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 `jps`，`jstat`，`jstack`，`jmap` 很有用。[SJK tools](https://github.com/aragozin/jvm-tools) 更高级。
    
- 使用 [`mtr`](http://www.bitwizard.nl/mtr/) 去跟踪路由，用于确定网络问题。
    
- 用 [`ncdu`](https://dev.yorhel.nl/ncdu) 来查看磁盘使用情况，它比寻常的命令，如 `du -sh *`，更节省时间。
    
- 查找正在使用带宽的套接字连接或进程，使用 [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) 或 [`nethogs`](https://github.com/raboof/nethogs)。
    
- `ab` 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 `siege`。
    
- [`wireshark`](https://wireshark.org/)，[`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html) 和 [`ngrep`](http://ngrep.sourceforge.net/) 可用于复杂的网络调试。
    
- 了解 `strace` 和 `ltrace`。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（`-c`）和附加到一个运行的进程参数 （`-p`）。
    
- 了解使用 `ldd` 来检查共享库。但是[永远不要在不信任的文件上运行](http://www.catonmat.net/blog/ldd-arbitrary-code-execution/)。
    
- 了解如何运用 `gdb` 连接到一个运行着的进程并获取它的堆栈轨迹。
    
- 学会使用 `/proc`。它在调试正在出现的问题的时候有时会效果惊人。比如：`/proc/cpuinfo`，`/proc/meminfo`，`/proc/cmdline`，`/proc/xxx/cwd`，`/proc/xxx/exe`，`/proc/xxx/fd/`，`/proc/xxx/smaps`（这里的 `xxx` 表示进程的 id 或 pid）。
    
- 当调试一些之前出现的问题的时候，[`sar`](http://sebastien.godard.pagesperso-orange.fr/) 非常有用。它展示了 cpu、内存以及网络等的历史数据。
    
- 关于更深层次的系统分析以及性能分析，看看 `stap`（[SystemTap](https://sourceware.org/systemtap/wiki)），[`perf`](https://en.wikipedia.org/wiki/Perf_\(Linux\))，以及[`sysdig`](https://github.com/draios/sysdig)。
    
- 查看你当前使用的系统，使用 `uname`，`uname -a`（Unix／kernel 信息）或者 `lsb_release -a`（Linux 发行版信息）。
    
- 无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 `dmesg`。
    
- 如果你删除了一个文件，但通过 `du` 发现没有释放预期的磁盘空间，请检查文件是否被进程占用： `lsof | grep deleted | grep "filename-of-my-big-file"`
    

## 单行脚本

[](https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md#%E5%8D%95%E8%A1%8C%E8%84%9A%E6%9C%AC)

一些命令组合的例子：

- 当你需要对文本文件做集合交、并、差运算时，`sort` 和 `uniq` 会是你的好帮手。具体例子请参照代码后面的，此处假设 `a` 与 `b` 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 `/tmp` 在一个小的根分区上时你可能需要 `-T` 参数，但是实际上 `sort` 并不被内存大小约束），参阅前文中关于 `LC_ALL` 和 `sort` 的 `-u` 参数的部分。

```shell
      sort a b | uniq > c   # c 是 a 并 b
      sort a b | uniq -d > c   # c 是 a 交 b
      sort a b b | uniq -u > c   # c 是 a - b
```

- 使用 `grep . *`（每行都会附上文件名）或者 `head -100 *`（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 `/sys`、`/proc`、`/etc`）时特别好用。
    
- 计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：
    

```shell
      awk '{ x += $3 } END { print x }' myfile
```

- 如果你想在文件树上查看大小/日期，这可能看起来像递归版的 `ls -l` 但比 `ls -lR` 更易于理解：

```shell
      find . -type f -ls
```

- 假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 `acct_id` 参数在 URI 中。如果你想计算出每个 `acct_id` 值有多少次请求，使用如下代码：

```shell
      egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn
```

- 要持续监测文件改动，可以使用 `watch`，例如检查某个文件夹中文件的改变，可以用 `watch -d -n 2 'ls -rtlh | tail'`；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 `watch -d -n 2 ifconfig`。
    
- 运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：
    

```shell
      function taocl() {
        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md|
          pandoc -f markdown -t html |
          iconv -f 'utf-8' -t 'unicode' |
          xmlstarlet fo --html --dropdtd |
          xmlstarlet sel -t -v "(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]" |
          xmlstarlet unesc | fmt -80
      }
```