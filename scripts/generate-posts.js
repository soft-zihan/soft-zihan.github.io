import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Setup for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// We scan the 'notes' directory for content.
// You should ensure all your markdown files are inside a 'notes' folder at the project root.
const NOTES_DIR = path.join(__dirname, '../notes');
const OUTPUT_FILE = path.join(__dirname, '../constants.ts');

// Recursive function to get all files
function getAllFiles(dirPath, arrayOfFiles = []) {
  if (!fs.existsSync(dirPath)) return arrayOfFiles;
  
  const files = fs.readdirSync(dirPath);

  files.forEach((file) => {
    const fullPath = path.join(dirPath, file);
    if (fs.statSync(fullPath).isDirectory()) {
      arrayOfFiles = getAllFiles(fullPath, arrayOfFiles);
    } else {
      if (file.endsWith('.md')) {
        arrayOfFiles.push(fullPath);
      }
    }
  });

  return arrayOfFiles;
}

// Ensure notes dir exists or fallback to just using what we can find
if (!fs.existsSync(NOTES_DIR)) {
    console.warn(`Warning: ${NOTES_DIR} does not exist. Creating empty default.`);
    fs.mkdirSync(NOTES_DIR, { recursive: true });
}

const mdFiles = getAllFiles(NOTES_DIR);

const posts = mdFiles.map((filePath, index) => {
  const content = fs.readFileSync(filePath, 'utf-8');
  
  // Simple frontmatter parser (looking for --- at start of file)
  const frontMatterMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
  
  let metadata = {};
  let body = content;

  if (frontMatterMatch) {
    const yaml = frontMatterMatch[1];
    body = frontMatterMatch[2];
    
    yaml.split('\n').forEach(line => {
      const parts = line.split(':');
      if (parts.length >= 2) {
        const key = parts[0].trim();
        const value = parts.slice(1).join(':').trim().replace(/(^"|"$)/g, ''); // Remove quotes
        
        if (key === 'tags') {
           // Handle list-like strings "[a, b]" or simple strings
           metadata[key] = value.replace(/[\[\]]/g, '').split(',').map(s => s.trim()).filter(Boolean);
        } else {
           metadata[key] = value;
        }
      }
    });
  }

  // Generate a relative path for the app (e.g., "notes/linux/command.md")
  // We want the path in the app to mirror the file system relative to the project root
  // If the file is at /project/notes/linux/foo.md, and we scanned /project/notes
  // relative is linux/foo.md. We probably want to prefix 'notes/' so it looks like root structure.
  const relativePath = path.relative(path.join(__dirname, '..'), filePath).replace(/\\/g, '/');
  
  // Fallback values
  const title = metadata.title || path.basename(filePath, '.md');
  const date = metadata.date || new Date().toISOString().split('T')[0];
  const tags = metadata.tags || ['uncategorized'];

  return {
    id: String(index + 1),
    title,
    path: relativePath, 
    date,
    tags,
    banner: metadata.banner,
    content: body
  };
});

const fileContent = `
import { BlogPost } from './types';

// AUTO-GENERATED BY scripts/generate-posts.js
export const MOCK_POSTS: BlogPost[] = ${JSON.stringify(posts, null, 2)};
`;

fs.writeFileSync(OUTPUT_FILE, fileContent);

console.log(`âœ… Generated constants.ts with ${posts.length} posts.`);
